/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _redux = __webpack_require__(1);
	
	// culture data, object and pre-sorted array of display names;
	var cultures = __webpack_require__(15).cultures;
	var cultures_list = __webpack_require__(15).cultures_list;
	
	// DOM references to select/option tags & shuffle btn
	var select_culture = document.getElementById('culture');
	var select_first_value = document.getElementById('first_value');
	var select_second_value = document.getElementById('second_value');
	var shuffle_button = document.getElementById('shuffle');
	
	// initial Cultures and Values chosen at random
	var initial_culture = randomCulture();
	var initial_state = {
	  culture: initial_culture,
	  first_value: randomValue(initial_culture),
	  second_value: randomValue(initial_culture)
	};
	
	// redux, see reducer
	
	var store = (0, _redux.createStore)(reducer);
	
	// initial application setup
	(function init() {
	  updateBackgroundGradient();
	  populateOptions();
	  populateCultures();
	  synchronizeSelectInputs();
	  updateCurrentHexToDOM();
	  store.subscribe(render);
	  console.log('INIT: ', store.getState());
	  shuffle_button.addEventListener('click', dispatchShuffle);
	  __webpack_require__(16)();
	})();
	
	// callback to run after every redux state change
	function render() {
	  updateBackgroundGradient();
	  populateOptions();
	  synchronizeSelectInputs();
	  updateCurrentHexToDOM();
	  console.log('RENDER: ', store.getState());
	}
	
	// takes a Culture and two Values, returns them as object/state
	function newState(culture, first_value, second_value) {
	  return { culture: culture, first_value: first_value, second_value: second_value };
	}
	
	function reducer(state, action) {
	  console.log('ACTION: ', action);
	  switch (action.type) {
	
	    case '@@redux/INIT':
	      return initial_state;
	
	    case 'CULTURE_CHANGE':
	      return newState(action.culture, randomValue(action.culture), randomValue(action.culture));
	
	    case 'VALUE_CHANGE':
	      var prev_store = store.getState();
	      if (action.side === 'LEFT') {
	        return newState(prev_store.culture, action.value, prev_store.second_value);
	      } else if (action.side === 'RIGHT') {
	        return newState(prev_store.culture, prev_store.first_value, action.value);
	      } else {
	        return state;
	      }
	
	    case 'SHUFFLE':
	      var rand_cult = randomCulture();
	      return newState(rand_cult, randomValue(rand_cult), randomValue(rand_cult));
	
	    default:
	      return state;
	  }
	}
	
	// updates background colors based on the current state
	function updateBackgroundGradient() {
	  var curr_state = store.getState();
	  var curr_culture = curr_state.culture;
	  var first_value = curr_state.first_value;
	  var second_value = curr_state.second_value;
	  var left_color = cultures[curr_culture][first_value];
	  var right_color = cultures[curr_culture][second_value];
	  var linear_gradient = 'linear-gradient(to right,' + left_color + ',' + right_color + ')';
	  document.body.style.background = linear_gradient;
	}
	
	// updates Culture and Values select tags to match user's choice
	function synchronizeSelectInputs() {
	  var state = store.getState();
	  var curr_culture_keys = Object.keys(cultures[state.culture]);
	  select_first_value.selectedIndex = curr_culture_keys.indexOf(state.first_value);
	  select_second_value.selectedIndex = curr_culture_keys.indexOf(state.second_value);
	  select_culture.selectedIndex = cultures_list.indexOf(store.getState().culture);
	}
	
	// clear Values and new options based on current Culture
	function populateOptions() {
	  select_first_value.innerHTML = select_second_value.innerHTML = '';
	  var state = store.getState();
	  var curr_culture_keys = Object.keys(cultures[state.culture]);
	  curr_culture_keys.forEach(add_option_value_to_select);
	}
	
	// adds a Value option to both select inputs
	function add_option_value_to_select(value) {
	  select_first_value.add(option_constructor(value));
	  select_second_value.add(option_constructor(value));
	}
	
	// constructs an option element given a Value
	function option_constructor(value) {
	  var option = document.createElement("option");
	  option.text = value;
	  option.nodeValue = value;
	  return option;
	}
	
	// populates the Culture input with options
	function populateCultures() {
	  select_culture.innerHTML = '';
	  cultures_list.forEach(function (culture) {
	    select_culture.add(option_constructor(culture));
	  });
	}
	
	// handler for left/right Values, dispatches action for value change
	function valueSelectHandler(event) {
	  var SIDE = event.target.id === 'first_value' ? 'LEFT' : 'RIGHT';
	  store.dispatch({
	    type: 'VALUE_CHANGE',
	    side: SIDE,
	    value: event.target.value
	  });
	}
	
	// handler for left/right Values, dispatches action for culture change
	function cultureSelectHandler(event) {
	  store.dispatch({
	    type: 'CULTURE_CHANGE',
	    culture: event.target.value
	  });
	}
	
	// handler for shuffle button, shuffles state
	function dispatchShuffle(e) {
	  store.dispatch({ type: 'SHUFFLE' });
	}
	
	// returns a random Value given a Culture
	function randomValue(culture) {
	  var culture_keys = Object.keys(cultures[culture]);
	  var rand_key = Math.floor(Math.random() * culture_keys.length);
	  return culture_keys[rand_key];
	}
	
	// returns a random Culture
	function randomCulture() {
	  var rand_key = Math.floor(Math.random() * cultures_list.length);
	  return cultures_list[rand_key];
	}
	
	// object lookup for current state's hex values, renders/updates to DOM
	function updateCurrentHexToDOM() {
	  var curr_state = store.getState();
	  var left_color = cultures[curr_state.culture][curr_state.first_value];
	  var right_color = cultures[curr_state.culture][curr_state.second_value];
	  document.getElementById('left_color_hex').innerText = left_color;
	  document.getElementById('right_color_hex').innerText = right_color;
	}

/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	exports.compose = exports.applyMiddleware = exports.bindActionCreators = exports.combineReducers = exports.createStore = undefined;
	
	var _createStore = __webpack_require__(3);
	
	var _createStore2 = _interopRequireDefault(_createStore);
	
	var _combineReducers = __webpack_require__(10);
	
	var _combineReducers2 = _interopRequireDefault(_combineReducers);
	
	var _bindActionCreators = __webpack_require__(12);
	
	var _bindActionCreators2 = _interopRequireDefault(_bindActionCreators);
	
	var _applyMiddleware = __webpack_require__(13);
	
	var _applyMiddleware2 = _interopRequireDefault(_applyMiddleware);
	
	var _compose = __webpack_require__(14);
	
	var _compose2 = _interopRequireDefault(_compose);
	
	var _warning = __webpack_require__(11);
	
	var _warning2 = _interopRequireDefault(_warning);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
	
	/*
	* This is a dummy function to check if the function name has been altered by minification.
	* If the function has been minified and NODE_ENV !== 'production', warn the user.
	*/
	function isCrushed() {}
	
	if (process.env.NODE_ENV !== 'production' && typeof isCrushed.name === 'string' && isCrushed.name !== 'isCrushed') {
	  (0, _warning2["default"])('You are currently using minified code outside of NODE_ENV === \'production\'. ' + 'This means that you are running a slower development build of Redux. ' + 'You can use loose-envify (https://github.com/zertosh/loose-envify) for browserify ' + 'or DefinePlugin for webpack (http://stackoverflow.com/questions/30030031) ' + 'to ensure you have the correct code for your production build.');
	}
	
	exports.createStore = _createStore2["default"];
	exports.combineReducers = _combineReducers2["default"];
	exports.bindActionCreators = _bindActionCreators2["default"];
	exports.applyMiddleware = _applyMiddleware2["default"];
	exports.compose = _compose2["default"];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ },
/* 2 */
/***/ function(module, exports) {

	// shim for using process in browser
	
	var process = module.exports = {};
	
	// cached from whatever global is present so that test runners that stub it
	// don't break things.  But we need to wrap it in a try catch in case it is
	// wrapped in strict mode code which doesn't define any globals.  It's inside a
	// function because try/catches deoptimize in certain engines.
	
	var cachedSetTimeout;
	var cachedClearTimeout;
	
	(function () {
	  try {
	    cachedSetTimeout = setTimeout;
	  } catch (e) {
	    cachedSetTimeout = function () {
	      throw new Error('setTimeout is not defined');
	    }
	  }
	  try {
	    cachedClearTimeout = clearTimeout;
	  } catch (e) {
	    cachedClearTimeout = function () {
	      throw new Error('clearTimeout is not defined');
	    }
	  }
	} ())
	var queue = [];
	var draining = false;
	var currentQueue;
	var queueIndex = -1;
	
	function cleanUpNextTick() {
	    if (!draining || !currentQueue) {
	        return;
	    }
	    draining = false;
	    if (currentQueue.length) {
	        queue = currentQueue.concat(queue);
	    } else {
	        queueIndex = -1;
	    }
	    if (queue.length) {
	        drainQueue();
	    }
	}
	
	function drainQueue() {
	    if (draining) {
	        return;
	    }
	    var timeout = cachedSetTimeout(cleanUpNextTick);
	    draining = true;
	
	    var len = queue.length;
	    while(len) {
	        currentQueue = queue;
	        queue = [];
	        while (++queueIndex < len) {
	            if (currentQueue) {
	                currentQueue[queueIndex].run();
	            }
	        }
	        queueIndex = -1;
	        len = queue.length;
	    }
	    currentQueue = null;
	    draining = false;
	    cachedClearTimeout(timeout);
	}
	
	process.nextTick = function (fun) {
	    var args = new Array(arguments.length - 1);
	    if (arguments.length > 1) {
	        for (var i = 1; i < arguments.length; i++) {
	            args[i - 1] = arguments[i];
	        }
	    }
	    queue.push(new Item(fun, args));
	    if (queue.length === 1 && !draining) {
	        cachedSetTimeout(drainQueue, 0);
	    }
	};
	
	// v8 likes predictible objects
	function Item(fun, array) {
	    this.fun = fun;
	    this.array = array;
	}
	Item.prototype.run = function () {
	    this.fun.apply(null, this.array);
	};
	process.title = 'browser';
	process.browser = true;
	process.env = {};
	process.argv = [];
	process.version = ''; // empty string to avoid regexp issues
	process.versions = {};
	
	function noop() {}
	
	process.on = noop;
	process.addListener = noop;
	process.once = noop;
	process.off = noop;
	process.removeListener = noop;
	process.removeAllListeners = noop;
	process.emit = noop;
	
	process.binding = function (name) {
	    throw new Error('process.binding is not supported');
	};
	
	process.cwd = function () { return '/' };
	process.chdir = function (dir) {
	    throw new Error('process.chdir is not supported');
	};
	process.umask = function() { return 0; };


/***/ },
/* 3 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	exports.ActionTypes = undefined;
	exports["default"] = createStore;
	
	var _isPlainObject = __webpack_require__(4);
	
	var _isPlainObject2 = _interopRequireDefault(_isPlainObject);
	
	var _symbolObservable = __webpack_require__(8);
	
	var _symbolObservable2 = _interopRequireDefault(_symbolObservable);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
	
	/**
	 * These are private action types reserved by Redux.
	 * For any unknown actions, you must return the current state.
	 * If the current state is undefined, you must return the initial state.
	 * Do not reference these action types directly in your code.
	 */
	var ActionTypes = exports.ActionTypes = {
	  INIT: '@@redux/INIT'
	};
	
	/**
	 * Creates a Redux store that holds the state tree.
	 * The only way to change the data in the store is to call `dispatch()` on it.
	 *
	 * There should only be a single store in your app. To specify how different
	 * parts of the state tree respond to actions, you may combine several reducers
	 * into a single reducer function by using `combineReducers`.
	 *
	 * @param {Function} reducer A function that returns the next state tree, given
	 * the current state tree and the action to handle.
	 *
	 * @param {any} [initialState] The initial state. You may optionally specify it
	 * to hydrate the state from the server in universal apps, or to restore a
	 * previously serialized user session.
	 * If you use `combineReducers` to produce the root reducer function, this must be
	 * an object with the same shape as `combineReducers` keys.
	 *
	 * @param {Function} enhancer The store enhancer. You may optionally specify it
	 * to enhance the store with third-party capabilities such as middleware,
	 * time travel, persistence, etc. The only store enhancer that ships with Redux
	 * is `applyMiddleware()`.
	 *
	 * @returns {Store} A Redux store that lets you read the state, dispatch actions
	 * and subscribe to changes.
	 */
	function createStore(reducer, initialState, enhancer) {
	  var _ref2;
	
	  if (typeof initialState === 'function' && typeof enhancer === 'undefined') {
	    enhancer = initialState;
	    initialState = undefined;
	  }
	
	  if (typeof enhancer !== 'undefined') {
	    if (typeof enhancer !== 'function') {
	      throw new Error('Expected the enhancer to be a function.');
	    }
	
	    return enhancer(createStore)(reducer, initialState);
	  }
	
	  if (typeof reducer !== 'function') {
	    throw new Error('Expected the reducer to be a function.');
	  }
	
	  var currentReducer = reducer;
	  var currentState = initialState;
	  var currentListeners = [];
	  var nextListeners = currentListeners;
	  var isDispatching = false;
	
	  function ensureCanMutateNextListeners() {
	    if (nextListeners === currentListeners) {
	      nextListeners = currentListeners.slice();
	    }
	  }
	
	  /**
	   * Reads the state tree managed by the store.
	   *
	   * @returns {any} The current state tree of your application.
	   */
	  function getState() {
	    return currentState;
	  }
	
	  /**
	   * Adds a change listener. It will be called any time an action is dispatched,
	   * and some part of the state tree may potentially have changed. You may then
	   * call `getState()` to read the current state tree inside the callback.
	   *
	   * You may call `dispatch()` from a change listener, with the following
	   * caveats:
	   *
	   * 1. The subscriptions are snapshotted just before every `dispatch()` call.
	   * If you subscribe or unsubscribe while the listeners are being invoked, this
	   * will not have any effect on the `dispatch()` that is currently in progress.
	   * However, the next `dispatch()` call, whether nested or not, will use a more
	   * recent snapshot of the subscription list.
	   *
	   * 2. The listener should not expect to see all state changes, as the state
	   * might have been updated multiple times during a nested `dispatch()` before
	   * the listener is called. It is, however, guaranteed that all subscribers
	   * registered before the `dispatch()` started will be called with the latest
	   * state by the time it exits.
	   *
	   * @param {Function} listener A callback to be invoked on every dispatch.
	   * @returns {Function} A function to remove this change listener.
	   */
	  function subscribe(listener) {
	    if (typeof listener !== 'function') {
	      throw new Error('Expected listener to be a function.');
	    }
	
	    var isSubscribed = true;
	
	    ensureCanMutateNextListeners();
	    nextListeners.push(listener);
	
	    return function unsubscribe() {
	      if (!isSubscribed) {
	        return;
	      }
	
	      isSubscribed = false;
	
	      ensureCanMutateNextListeners();
	      var index = nextListeners.indexOf(listener);
	      nextListeners.splice(index, 1);
	    };
	  }
	
	  /**
	   * Dispatches an action. It is the only way to trigger a state change.
	   *
	   * The `reducer` function, used to create the store, will be called with the
	   * current state tree and the given `action`. Its return value will
	   * be considered the **next** state of the tree, and the change listeners
	   * will be notified.
	   *
	   * The base implementation only supports plain object actions. If you want to
	   * dispatch a Promise, an Observable, a thunk, or something else, you need to
	   * wrap your store creating function into the corresponding middleware. For
	   * example, see the documentation for the `redux-thunk` package. Even the
	   * middleware will eventually dispatch plain object actions using this method.
	   *
	   * @param {Object} action A plain object representing “what changed”. It is
	   * a good idea to keep actions serializable so you can record and replay user
	   * sessions, or use the time travelling `redux-devtools`. An action must have
	   * a `type` property which may not be `undefined`. It is a good idea to use
	   * string constants for action types.
	   *
	   * @returns {Object} For convenience, the same action object you dispatched.
	   *
	   * Note that, if you use a custom middleware, it may wrap `dispatch()` to
	   * return something else (for example, a Promise you can await).
	   */
	  function dispatch(action) {
	    if (!(0, _isPlainObject2["default"])(action)) {
	      throw new Error('Actions must be plain objects. ' + 'Use custom middleware for async actions.');
	    }
	
	    if (typeof action.type === 'undefined') {
	      throw new Error('Actions may not have an undefined "type" property. ' + 'Have you misspelled a constant?');
	    }
	
	    if (isDispatching) {
	      throw new Error('Reducers may not dispatch actions.');
	    }
	
	    try {
	      isDispatching = true;
	      currentState = currentReducer(currentState, action);
	    } finally {
	      isDispatching = false;
	    }
	
	    var listeners = currentListeners = nextListeners;
	    for (var i = 0; i < listeners.length; i++) {
	      listeners[i]();
	    }
	
	    return action;
	  }
	
	  /**
	   * Replaces the reducer currently used by the store to calculate the state.
	   *
	   * You might need this if your app implements code splitting and you want to
	   * load some of the reducers dynamically. You might also need this if you
	   * implement a hot reloading mechanism for Redux.
	   *
	   * @param {Function} nextReducer The reducer for the store to use instead.
	   * @returns {void}
	   */
	  function replaceReducer(nextReducer) {
	    if (typeof nextReducer !== 'function') {
	      throw new Error('Expected the nextReducer to be a function.');
	    }
	
	    currentReducer = nextReducer;
	    dispatch({ type: ActionTypes.INIT });
	  }
	
	  /**
	   * Interoperability point for observable/reactive libraries.
	   * @returns {observable} A minimal observable of state changes.
	   * For more information, see the observable proposal:
	   * https://github.com/zenparsing/es-observable
	   */
	  function observable() {
	    var _ref;
	
	    var outerSubscribe = subscribe;
	    return _ref = {
	      /**
	       * The minimal observable subscription method.
	       * @param {Object} observer Any object that can be used as an observer.
	       * The observer object should have a `next` method.
	       * @returns {subscription} An object with an `unsubscribe` method that can
	       * be used to unsubscribe the observable from the store, and prevent further
	       * emission of values from the observable.
	       */
	
	      subscribe: function subscribe(observer) {
	        if (typeof observer !== 'object') {
	          throw new TypeError('Expected the observer to be an object.');
	        }
	
	        function observeState() {
	          if (observer.next) {
	            observer.next(getState());
	          }
	        }
	
	        observeState();
	        var unsubscribe = outerSubscribe(observeState);
	        return { unsubscribe: unsubscribe };
	      }
	    }, _ref[_symbolObservable2["default"]] = function () {
	      return this;
	    }, _ref;
	  }
	
	  // When a store is created, an "INIT" action is dispatched so that every
	  // reducer returns their initial state. This effectively populates
	  // the initial state tree.
	  dispatch({ type: ActionTypes.INIT });
	
	  return _ref2 = {
	    dispatch: dispatch,
	    subscribe: subscribe,
	    getState: getState,
	    replaceReducer: replaceReducer
	  }, _ref2[_symbolObservable2["default"]] = observable, _ref2;
	}

/***/ },
/* 4 */
/***/ function(module, exports, __webpack_require__) {

	var getPrototype = __webpack_require__(5),
	    isHostObject = __webpack_require__(6),
	    isObjectLike = __webpack_require__(7);
	
	/** `Object#toString` result references. */
	var objectTag = '[object Object]';
	
	/** Used for built-in method references. */
	var objectProto = Object.prototype;
	
	/** Used to resolve the decompiled source of functions. */
	var funcToString = Function.prototype.toString;
	
	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;
	
	/** Used to infer the `Object` constructor. */
	var objectCtorString = funcToString.call(Object);
	
	/**
	 * Used to resolve the
	 * [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)
	 * of values.
	 */
	var objectToString = objectProto.toString;
	
	/**
	 * Checks if `value` is a plain object, that is, an object created by the
	 * `Object` constructor or one with a `[[Prototype]]` of `null`.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.8.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a plain object,
	 *  else `false`.
	 * @example
	 *
	 * function Foo() {
	 *   this.a = 1;
	 * }
	 *
	 * _.isPlainObject(new Foo);
	 * // => false
	 *
	 * _.isPlainObject([1, 2, 3]);
	 * // => false
	 *
	 * _.isPlainObject({ 'x': 0, 'y': 0 });
	 * // => true
	 *
	 * _.isPlainObject(Object.create(null));
	 * // => true
	 */
	function isPlainObject(value) {
	  if (!isObjectLike(value) ||
	      objectToString.call(value) != objectTag || isHostObject(value)) {
	    return false;
	  }
	  var proto = getPrototype(value);
	  if (proto === null) {
	    return true;
	  }
	  var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;
	  return (typeof Ctor == 'function' &&
	    Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString);
	}
	
	module.exports = isPlainObject;


/***/ },
/* 5 */
/***/ function(module, exports) {

	/* Built-in method references for those with the same name as other `lodash` methods. */
	var nativeGetPrototype = Object.getPrototypeOf;
	
	/**
	 * Gets the `[[Prototype]]` of `value`.
	 *
	 * @private
	 * @param {*} value The value to query.
	 * @returns {null|Object} Returns the `[[Prototype]]`.
	 */
	function getPrototype(value) {
	  return nativeGetPrototype(Object(value));
	}
	
	module.exports = getPrototype;


/***/ },
/* 6 */
/***/ function(module, exports) {

	/**
	 * Checks if `value` is a host object in IE < 9.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a host object, else `false`.
	 */
	function isHostObject(value) {
	  // Many host objects are `Object` objects that can coerce to strings
	  // despite having improperly defined `toString` methods.
	  var result = false;
	  if (value != null && typeof value.toString != 'function') {
	    try {
	      result = !!(value + '');
	    } catch (e) {}
	  }
	  return result;
	}
	
	module.exports = isHostObject;


/***/ },
/* 7 */
/***/ function(module, exports) {

	/**
	 * Checks if `value` is object-like. A value is object-like if it's not `null`
	 * and has a `typeof` result of "object".
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
	 * @example
	 *
	 * _.isObjectLike({});
	 * // => true
	 *
	 * _.isObjectLike([1, 2, 3]);
	 * // => true
	 *
	 * _.isObjectLike(_.noop);
	 * // => false
	 *
	 * _.isObjectLike(null);
	 * // => false
	 */
	function isObjectLike(value) {
	  return !!value && typeof value == 'object';
	}
	
	module.exports = isObjectLike;


/***/ },
/* 8 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {/* global window */
	'use strict';
	
	module.exports = __webpack_require__(9)(global || window || this);
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 9 */
/***/ function(module, exports) {

	'use strict';
	
	module.exports = function symbolObservablePonyfill(root) {
		var result;
		var Symbol = root.Symbol;
	
		if (typeof Symbol === 'function') {
			if (Symbol.observable) {
				result = Symbol.observable;
			} else {
				result = Symbol('observable');
				Symbol.observable = result;
			}
		} else {
			result = '@@observable';
		}
	
		return result;
	};


/***/ },
/* 10 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	exports["default"] = combineReducers;
	
	var _createStore = __webpack_require__(3);
	
	var _isPlainObject = __webpack_require__(4);
	
	var _isPlainObject2 = _interopRequireDefault(_isPlainObject);
	
	var _warning = __webpack_require__(11);
	
	var _warning2 = _interopRequireDefault(_warning);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
	
	function getUndefinedStateErrorMessage(key, action) {
	  var actionType = action && action.type;
	  var actionName = actionType && '"' + actionType.toString() + '"' || 'an action';
	
	  return 'Given action ' + actionName + ', reducer "' + key + '" returned undefined. ' + 'To ignore an action, you must explicitly return the previous state.';
	}
	
	function getUnexpectedStateShapeWarningMessage(inputState, reducers, action) {
	  var reducerKeys = Object.keys(reducers);
	  var argumentName = action && action.type === _createStore.ActionTypes.INIT ? 'initialState argument passed to createStore' : 'previous state received by the reducer';
	
	  if (reducerKeys.length === 0) {
	    return 'Store does not have a valid reducer. Make sure the argument passed ' + 'to combineReducers is an object whose values are reducers.';
	  }
	
	  if (!(0, _isPlainObject2["default"])(inputState)) {
	    return 'The ' + argumentName + ' has unexpected type of "' + {}.toString.call(inputState).match(/\s([a-z|A-Z]+)/)[1] + '". Expected argument to be an object with the following ' + ('keys: "' + reducerKeys.join('", "') + '"');
	  }
	
	  var unexpectedKeys = Object.keys(inputState).filter(function (key) {
	    return !reducers.hasOwnProperty(key);
	  });
	
	  if (unexpectedKeys.length > 0) {
	    return 'Unexpected ' + (unexpectedKeys.length > 1 ? 'keys' : 'key') + ' ' + ('"' + unexpectedKeys.join('", "') + '" found in ' + argumentName + '. ') + 'Expected to find one of the known reducer keys instead: ' + ('"' + reducerKeys.join('", "') + '". Unexpected keys will be ignored.');
	  }
	}
	
	function assertReducerSanity(reducers) {
	  Object.keys(reducers).forEach(function (key) {
	    var reducer = reducers[key];
	    var initialState = reducer(undefined, { type: _createStore.ActionTypes.INIT });
	
	    if (typeof initialState === 'undefined') {
	      throw new Error('Reducer "' + key + '" returned undefined during initialization. ' + 'If the state passed to the reducer is undefined, you must ' + 'explicitly return the initial state. The initial state may ' + 'not be undefined.');
	    }
	
	    var type = '@@redux/PROBE_UNKNOWN_ACTION_' + Math.random().toString(36).substring(7).split('').join('.');
	    if (typeof reducer(undefined, { type: type }) === 'undefined') {
	      throw new Error('Reducer "' + key + '" returned undefined when probed with a random type. ' + ('Don\'t try to handle ' + _createStore.ActionTypes.INIT + ' or other actions in "redux/*" ') + 'namespace. They are considered private. Instead, you must return the ' + 'current state for any unknown actions, unless it is undefined, ' + 'in which case you must return the initial state, regardless of the ' + 'action type. The initial state may not be undefined.');
	    }
	  });
	}
	
	/**
	 * Turns an object whose values are different reducer functions, into a single
	 * reducer function. It will call every child reducer, and gather their results
	 * into a single state object, whose keys correspond to the keys of the passed
	 * reducer functions.
	 *
	 * @param {Object} reducers An object whose values correspond to different
	 * reducer functions that need to be combined into one. One handy way to obtain
	 * it is to use ES6 `import * as reducers` syntax. The reducers may never return
	 * undefined for any action. Instead, they should return their initial state
	 * if the state passed to them was undefined, and the current state for any
	 * unrecognized action.
	 *
	 * @returns {Function} A reducer function that invokes every reducer inside the
	 * passed object, and builds a state object with the same shape.
	 */
	function combineReducers(reducers) {
	  var reducerKeys = Object.keys(reducers);
	  var finalReducers = {};
	  for (var i = 0; i < reducerKeys.length; i++) {
	    var key = reducerKeys[i];
	    if (typeof reducers[key] === 'function') {
	      finalReducers[key] = reducers[key];
	    }
	  }
	  var finalReducerKeys = Object.keys(finalReducers);
	
	  var sanityError;
	  try {
	    assertReducerSanity(finalReducers);
	  } catch (e) {
	    sanityError = e;
	  }
	
	  return function combination() {
	    var state = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
	    var action = arguments[1];
	
	    if (sanityError) {
	      throw sanityError;
	    }
	
	    if (process.env.NODE_ENV !== 'production') {
	      var warningMessage = getUnexpectedStateShapeWarningMessage(state, finalReducers, action);
	      if (warningMessage) {
	        (0, _warning2["default"])(warningMessage);
	      }
	    }
	
	    var hasChanged = false;
	    var nextState = {};
	    for (var i = 0; i < finalReducerKeys.length; i++) {
	      var key = finalReducerKeys[i];
	      var reducer = finalReducers[key];
	      var previousStateForKey = state[key];
	      var nextStateForKey = reducer(previousStateForKey, action);
	      if (typeof nextStateForKey === 'undefined') {
	        var errorMessage = getUndefinedStateErrorMessage(key, action);
	        throw new Error(errorMessage);
	      }
	      nextState[key] = nextStateForKey;
	      hasChanged = hasChanged || nextStateForKey !== previousStateForKey;
	    }
	    return hasChanged ? nextState : state;
	  };
	}
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ },
/* 11 */
/***/ function(module, exports) {

	'use strict';
	
	exports.__esModule = true;
	exports["default"] = warning;
	/**
	 * Prints a warning in the console if it exists.
	 *
	 * @param {String} message The warning message.
	 * @returns {void}
	 */
	function warning(message) {
	  /* eslint-disable no-console */
	  if (typeof console !== 'undefined' && typeof console.error === 'function') {
	    console.error(message);
	  }
	  /* eslint-enable no-console */
	  try {
	    // This error was thrown as a convenience so that if you enable
	    // "break on all exceptions" in your console,
	    // it would pause the execution at this line.
	    throw new Error(message);
	    /* eslint-disable no-empty */
	  } catch (e) {}
	  /* eslint-enable no-empty */
	}

/***/ },
/* 12 */
/***/ function(module, exports) {

	'use strict';
	
	exports.__esModule = true;
	exports["default"] = bindActionCreators;
	function bindActionCreator(actionCreator, dispatch) {
	  return function () {
	    return dispatch(actionCreator.apply(undefined, arguments));
	  };
	}
	
	/**
	 * Turns an object whose values are action creators, into an object with the
	 * same keys, but with every function wrapped into a `dispatch` call so they
	 * may be invoked directly. This is just a convenience method, as you can call
	 * `store.dispatch(MyActionCreators.doSomething())` yourself just fine.
	 *
	 * For convenience, you can also pass a single function as the first argument,
	 * and get a function in return.
	 *
	 * @param {Function|Object} actionCreators An object whose values are action
	 * creator functions. One handy way to obtain it is to use ES6 `import * as`
	 * syntax. You may also pass a single function.
	 *
	 * @param {Function} dispatch The `dispatch` function available on your Redux
	 * store.
	 *
	 * @returns {Function|Object} The object mimicking the original object, but with
	 * every action creator wrapped into the `dispatch` call. If you passed a
	 * function as `actionCreators`, the return value will also be a single
	 * function.
	 */
	function bindActionCreators(actionCreators, dispatch) {
	  if (typeof actionCreators === 'function') {
	    return bindActionCreator(actionCreators, dispatch);
	  }
	
	  if (typeof actionCreators !== 'object' || actionCreators === null) {
	    throw new Error('bindActionCreators expected an object or a function, instead received ' + (actionCreators === null ? 'null' : typeof actionCreators) + '. ' + 'Did you write "import ActionCreators from" instead of "import * as ActionCreators from"?');
	  }
	
	  var keys = Object.keys(actionCreators);
	  var boundActionCreators = {};
	  for (var i = 0; i < keys.length; i++) {
	    var key = keys[i];
	    var actionCreator = actionCreators[key];
	    if (typeof actionCreator === 'function') {
	      boundActionCreators[key] = bindActionCreator(actionCreator, dispatch);
	    }
	  }
	  return boundActionCreators;
	}

/***/ },
/* 13 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
	
	exports["default"] = applyMiddleware;
	
	var _compose = __webpack_require__(14);
	
	var _compose2 = _interopRequireDefault(_compose);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
	
	/**
	 * Creates a store enhancer that applies middleware to the dispatch method
	 * of the Redux store. This is handy for a variety of tasks, such as expressing
	 * asynchronous actions in a concise manner, or logging every action payload.
	 *
	 * See `redux-thunk` package as an example of the Redux middleware.
	 *
	 * Because middleware is potentially asynchronous, this should be the first
	 * store enhancer in the composition chain.
	 *
	 * Note that each middleware will be given the `dispatch` and `getState` functions
	 * as named arguments.
	 *
	 * @param {...Function} middlewares The middleware chain to be applied.
	 * @returns {Function} A store enhancer applying the middleware.
	 */
	function applyMiddleware() {
	  for (var _len = arguments.length, middlewares = Array(_len), _key = 0; _key < _len; _key++) {
	    middlewares[_key] = arguments[_key];
	  }
	
	  return function (createStore) {
	    return function (reducer, initialState, enhancer) {
	      var store = createStore(reducer, initialState, enhancer);
	      var _dispatch = store.dispatch;
	      var chain = [];
	
	      var middlewareAPI = {
	        getState: store.getState,
	        dispatch: function dispatch(action) {
	          return _dispatch(action);
	        }
	      };
	      chain = middlewares.map(function (middleware) {
	        return middleware(middlewareAPI);
	      });
	      _dispatch = _compose2["default"].apply(undefined, chain)(store.dispatch);
	
	      return _extends({}, store, {
	        dispatch: _dispatch
	      });
	    };
	  };
	}

/***/ },
/* 14 */
/***/ function(module, exports) {

	"use strict";
	
	exports.__esModule = true;
	exports["default"] = compose;
	/**
	 * Composes single-argument functions from right to left. The rightmost
	 * function can take multiple arguments as it provides the signature for
	 * the resulting composite function.
	 *
	 * @param {...Function} funcs The functions to compose.
	 * @returns {Function} A function obtained by composing the argument functions
	 * from right to left. For example, compose(f, g, h) is identical to doing
	 * (...args) => f(g(h(...args))).
	 */
	
	function compose() {
	  for (var _len = arguments.length, funcs = Array(_len), _key = 0; _key < _len; _key++) {
	    funcs[_key] = arguments[_key];
	  }
	
	  if (funcs.length === 0) {
	    return function (arg) {
	      return arg;
	    };
	  } else {
	    var _ret = function () {
	      var last = funcs[funcs.length - 1];
	      var rest = funcs.slice(0, -1);
	      return {
	        v: function v() {
	          return rest.reduceRight(function (composed, f) {
	            return f(composed);
	          }, last.apply(undefined, arguments));
	        }
	      };
	    }();
	
	    if (typeof _ret === "object") return _ret.v;
	  }
	}

/***/ },
/* 15 */
/***/ function(module, exports) {

	'use strict';
	
	var _eastern_european;
	
	function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
	
	// src (for most): https://flatuicolors.com/
	var RED = '#E74C3C',
	    ORANGE = '#E67E22',
	    PURPLE = '#9B59B6',
	    BLUE = '#2980B9',
	    PINK = '#E91E63',
	    YELLOW = '#F1C40F',
	    GOLD = '#F39C12',
	    GREEN = '#2ECC71',
	    GREY = '#7F8C8D',
	    SILVER = '#BDC3C7',
	    WHITE = '#ECF0F1',
	    BLACK = '#000000',
	    BROWN = '#795548';
	
	// infographic inspiration:
	// http://www.informationisbeautiful.net/visualizations/colours-in-cultures/
	
	var western = {
	    'Anger': RED,
	    'Authority': BLACK,
	    'Beauty': PURPLE,
	    'Children': PINK,
	    'Cold': BLUE,
	    'Courage': ORANGE,
	    'Cowardice': YELLOW,
	    'Cruelty': PURPLE,
	    'Danger': RED,
	    'Death': BLACK,
	    'Decadence': PURPLE,
	    'Desire': RED,
	    'Earthy': BROWN,
	    'Energy': YELLOW,
	    'Erotic': ORANGE,
	    'Femininity': PINK,
	    'Flamboyance': PURPLE,
	    'Freedom': BLUE,
	    'Friendly': ORANGE,
	    'Fun': YELLOW,
	    'Good Luck': GREEN,
	    'Growth': GREEN,
	    'Happiness': YELLOW,
	    'Healing': BLUE,
	    'Heat': RED,
	    'Heaven': WHITE,
	    'Intelligence': BLUE,
	    'Jealousy': GREEN,
	    'Love': RED,
	    'Loyalty': BLUE,
	    'Luxury': WHITE,
	    'Marriage': WHITE,
	    'Modesty': PURPLE,
	    'Money': GOLD,
	    'Mourning': BLACK,
	    'Mystery': PURPLE,
	    'Nature': GREEN,
	    'Passion': RED,
	    'Peace': YELLOW,
	    'Personal Power': PURPLE,
	    'Purity': WHITE,
	    'Radicalism': RED,
	    'Rational': BLUE,
	    'Reliable': BROWN,
	    'Repels Evil': YELLOW,
	    'Respect': GREY,
	    'Style': BLACK,
	    'Truce': WHITE,
	    'Unhappiness': BLUE,
	    'Virtue': PURPLE
	};
	
	var japanese = {
	    'Art/Creativity': RED,
	    'Bad Luck': BLACK,
	    'Balance': ORANGE,
	    'Celebration': PURPLE,
	    'Children': PINK,
	    'Cold': BLUE,
	    'Courage': YELLOW,
	    'Cowardice': YELLOW,
	    'Danger': RED,
	    'Death': BLACK,
	    'Decadence': PURPLE,
	    'Deceit': YELLOW,
	    'Desire': RED,
	    'Energy': ORANGE,
	    'Erotic': PINK,
	    'Eternity': GREEN,
	    'Evil': BLACK,
	    'Excitement': RED,
	    'Flamboyance': ORANGE,
	    'God': PURPLE,
	    'Good Luck': GREEN,
	    'Healthy': PINK,
	    'Heaven': YELLOW,
	    'Holiness': WHITE,
	    'Ilness': YELLOW,
	    'Insight': PURPLE,
	    'Intelligence': SILVER,
	    'Religion': YELLOW,
	    'Jealousy': GREEN,
	    'Joy': YELLOW,
	    'Life': BLUE,
	    'Love': RED,
	    'Loyalty': BLUE,
	    'Modesty': GREY,
	    'Money': BLUE,
	    'Mystery': PURPLE,
	    'Nature': GREEN,
	    'Passion': RED,
	    'Peace': BLUE,
	    'Purity': WHITE,
	    'Rational': BLUE,
	    'Reliable': GREY,
	    'Repels Evil': RED,
	    'Respect': WHITE,
	    'Strength': RED,
	    'Style': BLACK,
	    'Truce': WHITE,
	    'Unhappiness': BLACK,
	    'Warmth': ORANGE,
	    'Wisdom': PURPLE
	};
	
	var hindu = {
	    'Anger': BLACK,
	    'Art/Creativity': BLUE,
	    'Compassion': GREEN,
	    'Courage': ORANGE,
	    'Death': WHITE,
	    'Desire': ORANGE,
	    'Energy': RED,
	    'Erotic': RED,
	    'Evil': BLACK,
	    'Fun': YELLOW,
	    'God': YELLOW,
	    'Gods': BLUE,
	    'Happiness': GREEN,
	    'Heat': RED,
	    'Illness': YELLOW,
	    'Insight': GREEN,
	    'Intelligence': WHITE,
	    'Intuition': PURPLE,
	    'Religion': GREEN,
	    'Joy': YELLOW,
	    'Life': GREEN,
	    'Love': GREEN,
	    'Marriage': RED,
	    'Passion': RED,
	    'Peace': WHITE,
	    'Penance': BLACK,
	    'Personal Power': YELLOW,
	    'Repels Evil': YELLOW,
	    'Truce': WHITE,
	    'Wisdom': PURPLE
	};
	
	var native_american = {
	    'Balance': BLACK,
	    'Cold': BLUE,
	    'Danger': YELLOW,
	    'Death': BLACK,
	    'Friendly': GREY,
	    'Gratitude': PURPLE,
	    'Happiness': WHITE,
	    'Healing': ORANGE,
	    'Insight': YELLOW,
	    'Intuition': BLUE,
	    'Learning': ORANGE,
	    'Love': YELLOW,
	    'Passion': RED,
	    'Peace': WHITE,
	    'Personal Power': GREEN,
	    'Respect': SILVER,
	    'Self-Cultivation': BLACK,
	    'Success': RED,
	    'Trouble': BLUE,
	    'Unhappiness': BLUE,
	    'Wisdom': BROWN
	};
	
	var chinese = {
	    'Celebration': BLACK,
	    'Death': WHITE,
	    'Earthy': BROWN,
	    'Family': ORANGE,
	    'Fertility': RED,
	    'Good Luck': RED,
	    'Growth': GREEN,
	    'Happiness': RED,
	    'Healthy': YELLOW,
	    'Learning': ORANGE,
	    'Life': GREEN,
	    'Marriage': RED,
	    'Mourning': WHITE,
	    'Repels Evil': GREEN,
	    'Respect': YELLOW,
	    'Royalty': YELLOW,
	    'Success': RED,
	    'Money': GOLD,
	    'Purity': WHITE,
	    'Truce': WHITE
	};
	
	var asian = {
	    'Balance': GREEN,
	    'Children': WHITE,
	    'Eternity': GREEN,
	    'Evil': BLACK,
	    'Excitement': GREEN,
	    'Flamboyance': PURPLE,
	    'Happiness': RED,
	    'Holiness': YELLOW,
	    'Intelligence': BLACK,
	    'Money': GOLD,
	    'Penance': BLACK,
	    'Power': YELLOW,
	    'Purity': WHITE,
	    'Repels Evil': YELLOW,
	    'Self Cultivation': BLACK,
	    'Strength': YELLOW,
	    'Success': RED
	};
	
	var eastern_european = (_eastern_european = {
	    'Anger': RED,
	    'Heat': RED,
	    'Beauty': RED,
	    'Good Luck': RED
	}, _defineProperty(_eastern_european, 'Heat', RED), _defineProperty(_eastern_european, 'Love', RED), _defineProperty(_eastern_european, 'Loyalty', BLUE), _defineProperty(_eastern_european, 'Mourning', YELLOW), _defineProperty(_eastern_european, 'Passion', RED), _defineProperty(_eastern_european, 'Power', RED), _defineProperty(_eastern_european, 'Radicalism', RED), _defineProperty(_eastern_european, 'Truce', WHITE), _defineProperty(_eastern_european, 'Trust', WHITE), _defineProperty(_eastern_european, 'Virtue', BLUE), _defineProperty(_eastern_european, 'Wisdom', BLUE), _eastern_european);
	
	var muslim = {
	    'Death': SILVER,
	    'God': GREEN,
	    'Good Luck': GREEN,
	    'Heat': RED,
	    'Heaven': GREEN,
	    'Religion': GREEN,
	    'Peace': SILVER,
	    'Purity': SILVER,
	    'Strength': YELLOW,
	    'Truce': SILVER
	};
	
	var african = {
	    'Anger': RED,
	    'Good Luck': RED,
	    'Religion': GREEN,
	    'Learning': GREEN,
	    'Life': BLUE,
	    'Peace': BLUE,
	    'Success': GREEN,
	    'Truce': GREY
	};
	
	var south_american = {
	    'Danger': RED,
	    'Death': GREEN,
	    'Mourning': PURPLE,
	    'Success': RED,
	    'Trouble': BLUE
	};
	
	// String->Object lookup table
	var cultures = {
	    'Western': western,
	    'Japanese': japanese,
	    'Hindu': hindu,
	    'Native American': native_american,
	    'Chinese': chinese,
	    'Asian': asian,
	    'Eastern European': eastern_european,
	    'Muslim': muslim,
	    'African': african,
	    'South American': south_american
	};
	
	// alphabetized array of cultures
	var cultures_list = ["African", "Asian", "Chinese", "Eastern European", "Hindu", "Japanese", "Muslim", "Native American", "South American", "Western"];
	
	exports.cultures = cultures;
	exports.cultures_list = cultures_list;

/***/ },
/* 16 */
/***/ function(module, exports) {

	'use strict';
	
	// 1. Google Analytics
	// 2. rotates throughout the flat UI colors for the heart at the border-bottom.
	// 3. 3rd-party library for inline-tweets sharing functionality.
	
	module.exports = function () {
	    'use strict';
	
	    (function (i, s, o, g, r, a, m) {
	        i['GoogleAnalyticsObject'] = r;i[r] = i[r] || function () {
	            (i[r].q = i[r].q || []).push(arguments);
	        }, i[r].l = 1 * new Date();a = s.createElement(o), m = s.getElementsByTagName(o)[0];a.async = 1;a.src = g;m.parentNode.insertBefore(a, m);
	    })(window, document, 'script', 'https://www.google-analytics.com/analytics.js', 'ga');
	    ga('create', 'UA-76555000-1', 'auto');
	    ga('send', 'pageview');
	    // loops through heart icon (footer) colors
	    var $heart = document.getElementById('#heart');
	    var flatUIColors = ['#34495e', '#5900ff', '#9b59b6', '#3498db', '#2ecc71', '#1abc9c', '#f1c40f', '#ecf0f1', '#e67e22', '#e74c3c', '#95a5a6'];
	    var counter = 0;
	    var updateInterval = 1000;
	    setInterval(function changeHeartColor() {
	        if (!flatUIColors[counter]) counter = 0;
	        heart.style.color = flatUIColors[counter++];
	    }, updateInterval);
	    // inlineTweet.js
	    function buildInlineTweet(e) {
	        var t = e.innerHTML,
	            i = "%22" + encodeURIComponent(t) + "%22",
	            n = e.dataset.inlineTweetUrl ? e.dataset.inlineTweetUrl : window.location.href,
	            a = e.dataset.inlineTweetVia ? "&via=" + e.dataset.inlineTweetVia : "",
	            r = e.dataset.inlineTweetTags ? "&hashtags=" + e.dataset.inlineTweetTags : "",
	            l = "https://twitter.com/intent/tweet/?text=" + i + "&url=" + n + a + r,
	            d = document.createElement("span");
	        d.innerHTML = t;
	        var s = document.createElement("a");
	        s.target = "_blank", s.href = l, s.appendChild(d), s.innerHTML += twitterLogo, e.innerHTML = "", e.appendChild(s);
	    }
	    var inlineTweets = document.querySelectorAll("*[data-inline-tweet]");
	    if (inlineTweets) for (var twitterLogo = '<svg style="height: 0.7em;" xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#" xmlns="http://www.w3.org/2000/svg" xml:space="preserve" version="1.1" xmlns:cc="http://creativecommons.org/ns#" viewBox="0 0 182.66667 150.66667" xmlns:dc="http://purl.org/dc/elements/1.1/"><metadata id="metadata8"><rdf:RDF><cc:Work rdf:about=""><dc:format>image/svg+xml</dc:format><dc:type rdf:resource="http://purl.org/dc/dcmitype/StillImage"/></cc:Work></rdf:RDF></metadata><defs id="defs6"><clipPath id="clipPath20" clipPathUnits="userSpaceOnUse"><path id="path18" d="m0 10.012h1366.9v1110.9h-1366.9z"/></clipPath></defs><g id="g10" transform="matrix(1.3333 0 0 -1.3333 0 150.67)"><g id="g12" transform="scale(.1)"><g id="g14"><g id="g16" clip-path="url(#clipPath20)"><path id="path22" d="m1366.9 989.39c-50.27-22.309-104.33-37.387-161.05-44.18 57.89 34.723 102.34 89.679 123.28 155.15-54.18-32.15-114.18-55.47-178.09-68.04-51.13 54.49-124.02 88.55-204.68 88.55-154.89 0-280.43-125.55-280.43-280.43 0-21.988 2.457-43.398 7.258-63.91-233.08 11.68-439.72 123.36-578.04 293.01-24.141-41.4-37.969-89.567-37.969-140.97 0-97.308 49.489-183.13 124.76-233.44-45.969 1.437-89.218 14.058-127.03 35.078-0.043-1.18-0.043-2.348-0.043-3.52 0-135.9 96.68-249.22 224.96-275-23.512-6.41-48.281-9.8-73.86-9.8-18.089 0-35.628 1.711-52.781 5 35.711-111.41 139.26-192.5 262-194.77-96.058-75.23-216.96-120.04-348.36-120.04-22.621 0-44.961 1.332-66.918 3.91 124.16-79.568 271.55-125.98 429.94-125.98 515.82 0 797.86 427.31 797.86 797.93 0 12.153-0.28 24.223-0.79 36.25 54.77 39.571 102.31 88.95 139.93 145.2" fill="#55ACEE"/></g></g></g></g></svg>', i = 0; i < inlineTweets.length; i++) {
	        buildInlineTweet(inlineTweets[i]);
	    }
	};

/***/ }
/******/ ]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAgYjM0ZjM0MDYyOWJlNTZlZTM0ZjQiLCJ3ZWJwYWNrOi8vLy4vbWFpbi5qcyIsIndlYnBhY2s6Ly8vLi4vfi9yZWR1eC9saWIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4uL34vcHJvY2Vzcy9icm93c2VyLmpzIiwid2VicGFjazovLy8uLi9+L3JlZHV4L2xpYi9jcmVhdGVTdG9yZS5qcyIsIndlYnBhY2s6Ly8vLi4vfi9yZWR1eC9+L2xvZGFzaC9pc1BsYWluT2JqZWN0LmpzIiwid2VicGFjazovLy8uLi9+L3JlZHV4L34vbG9kYXNoL19nZXRQcm90b3R5cGUuanMiLCJ3ZWJwYWNrOi8vLy4uL34vcmVkdXgvfi9sb2Rhc2gvX2lzSG9zdE9iamVjdC5qcyIsIndlYnBhY2s6Ly8vLi4vfi9yZWR1eC9+L2xvZGFzaC9pc09iamVjdExpa2UuanMiLCJ3ZWJwYWNrOi8vLy4uL34vc3ltYm9sLW9ic2VydmFibGUvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4uL34vc3ltYm9sLW9ic2VydmFibGUvcG9ueWZpbGwuanMiLCJ3ZWJwYWNrOi8vLy4uL34vcmVkdXgvbGliL2NvbWJpbmVSZWR1Y2Vycy5qcyIsIndlYnBhY2s6Ly8vLi4vfi9yZWR1eC9saWIvdXRpbHMvd2FybmluZy5qcyIsIndlYnBhY2s6Ly8vLi4vfi9yZWR1eC9saWIvYmluZEFjdGlvbkNyZWF0b3JzLmpzIiwid2VicGFjazovLy8uLi9+L3JlZHV4L2xpYi9hcHBseU1pZGRsZXdhcmUuanMiLCJ3ZWJwYWNrOi8vLy4uL34vcmVkdXgvbGliL2NvbXBvc2UuanMiLCJ3ZWJwYWNrOi8vLy4vY3VsdHVyZV9kYXRhLmpzIiwid2VicGFjazovLy8uL2V4dHJhcy5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsdUJBQWU7QUFDZjtBQUNBO0FBQ0E7O0FBRUE7QUFD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cyIsInNvdXJjZXNDb250ZW50IjpbIiBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbiBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG5cbiBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cbiBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKVxuIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuXG4gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbiBcdFx0XHRleHBvcnRzOiB7fSxcbiBcdFx0XHRpZDogbW9kdWxlSWQsXG4gXHRcdFx0bG9hZGVkOiBmYWxzZVxuIFx0XHR9O1xuXG4gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4gXHRcdG1vZHVsZS5sb2FkZWQgPSB0cnVlO1xuXG4gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbiBcdH1cblxuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbiBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG5cbiBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIlwiO1xuXG4gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbiBcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogd2VicGFjay9ib290c3RyYXAgYjM0ZjM0MDYyOWJlNTZlZTM0ZjRcbiAqKi8iLCIvLyBjdWx0dXJlIGRhdGEsIG9iamVjdCBhbmQgcHJlLXNvcnRlZCBhcnJheSBvZiBkaXNwbGF5IG5hbWVzO1xuY29uc3QgY3VsdHVyZXMgPSByZXF1aXJlKCcuL2N1bHR1cmVfZGF0YScpLmN1bHR1cmVzO1xuY29uc3QgY3VsdHVyZXNfbGlzdCA9IHJlcXVpcmUoJy4vY3VsdHVyZV9kYXRhJykuY3VsdHVyZXNfbGlzdDtcblxuLy8gRE9NIHJlZmVyZW5jZXMgdG8gc2VsZWN0L29wdGlvbiB0YWdzICYgc2h1ZmZsZSBidG5cbmNvbnN0IHNlbGVjdF9jdWx0dXJlID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2N1bHR1cmUnKTtcbmNvbnN0IHNlbGVjdF9maXJzdF92YWx1ZSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdmaXJzdF92YWx1ZScpO1xuY29uc3Qgc2VsZWN0X3NlY29uZF92YWx1ZSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdzZWNvbmRfdmFsdWUnKTtcbmxldCBzaHVmZmxlX2J1dHRvbiA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdzaHVmZmxlJyk7XG5cbi8vIGluaXRpYWwgQ3VsdHVyZXMgYW5kIFZhbHVlcyBjaG9zZW4gYXQgcmFuZG9tXG5jb25zdCBpbml0aWFsX2N1bHR1cmUgPSByYW5kb21DdWx0dXJlKCk7XG5jb25zdCBpbml0aWFsX3N0YXRlID0ge1xuICBjdWx0dXJlOiBpbml0aWFsX2N1bHR1cmUsXG4gIGZpcnN0X3ZhbHVlOiByYW5kb21WYWx1ZShpbml0aWFsX2N1bHR1cmUpLFxuICBzZWNvbmRfdmFsdWU6IHJhbmRvbVZhbHVlKGluaXRpYWxfY3VsdHVyZSlcbn07XG5cbi8vIHJlZHV4LCBzZWUgcmVkdWNlclxuaW1wb3J0IHsgY3JlYXRlU3RvcmUgfSBmcm9tICdyZWR1eCc7XG5sZXQgc3RvcmUgPSBjcmVhdGVTdG9yZShyZWR1Y2VyKTtcblxuLy8gaW5pdGlhbCBhcHBsaWNhdGlvbiBzZXR1cFxuKGZ1bmN0aW9uIGluaXQoKXtcbiAgdXBkYXRlQmFja2dyb3VuZEdyYWRpZW50KCk7XG4gIHBvcHVsYXRlT3B0aW9ucygpO1xuICBwb3B1bGF0ZUN1bHR1cmVzKCk7XG4gIHN5bmNocm9uaXplU2VsZWN0SW5wdXRzKCk7XG4gIHVwZGF0ZUN1cnJlbnRIZXhUb0RPTSgpXG4gIHN0b3JlLnN1YnNjcmliZShyZW5kZXIpO1xuICBjb25zb2xlLmxvZygnSU5JVDogJywgc3RvcmUuZ2V0U3RhdGUoKSk7XG4gIHNodWZmbGVfYnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZGlzcGF0Y2hTaHVmZmxlKTtcbiAgcmVxdWlyZSgnLi9leHRyYXMnKSgpO1xufSgpKVxuXG4vLyBjYWxsYmFjayB0byBydW4gYWZ0ZXIgZXZlcnkgcmVkdXggc3RhdGUgY2hhbmdlXG5mdW5jdGlvbiByZW5kZXIoKSB7XG4gIHVwZGF0ZUJhY2tncm91bmRHcmFkaWVudCgpO1xuICBwb3B1bGF0ZU9wdGlvbnMoKTtcbiAgc3luY2hyb25pemVTZWxlY3RJbnB1dHMoKTtcbiAgdXBkYXRlQ3VycmVudEhleFRvRE9NKCk7XG4gIGNvbnNvbGUubG9nKCdSRU5ERVI6ICcsIHN0b3JlLmdldFN0YXRlKCkpO1xufVxuXG4vLyB0YWtlcyBhIEN1bHR1cmUgYW5kIHR3byBWYWx1ZXMsIHJldHVybnMgdGhlbSBhcyBvYmplY3Qvc3RhdGVcbmZ1bmN0aW9uIG5ld1N0YXRlKGN1bHR1cmUsIGZpcnN0X3ZhbHVlLCBzZWNvbmRfdmFsdWUpIHtcbiAgcmV0dXJuIHsgY3VsdHVyZSwgZmlyc3RfdmFsdWUsIHNlY29uZF92YWx1ZSB9XG59XG5cblxuZnVuY3Rpb24gcmVkdWNlcihzdGF0ZSwgYWN0aW9uKSB7XG4gIGNvbnNvbGUubG9nKCdBQ1RJT046ICcsIGFjdGlvbik7XG4gIHN3aXRjaCAoYWN0aW9uLnR5cGUpIHtcblxuICAgIGNhc2UgJ0BAcmVkdXgvSU5JVCc6IHJldHVybiBpbml0aWFsX3N0YXRlXG5cbiAgICBjYXNlICdDVUxUVVJFX0NIQU5HRSc6XG4gICAgICByZXR1cm4gbmV3U3RhdGUoYWN0aW9uLmN1bHR1cmUsIHJhbmRvbVZhbHVlKGFjdGlvbi5jdWx0dXJlKSwgcmFuZG9tVmFsdWUoYWN0aW9uLmN1bHR1cmUpKVxuXG4gICAgY2FzZSAnVkFMVUVfQ0hBTkdFJzpcbiAgICAgIGxldCBwcmV2X3N0b3JlID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICAgIGlmIChhY3Rpb24uc2lkZSA9PT0gJ0xFRlQnKSB7XG4gICAgICAgIHJldHVybiBuZXdTdGF0ZShwcmV2X3N0b3JlLmN1bHR1cmUsIGFjdGlvbi52YWx1ZSwgcHJldl9zdG9yZS5zZWNvbmRfdmFsdWUpXG4gICAgICB9IGVsc2UgaWYgKGFjdGlvbi5zaWRlID09PSAnUklHSFQnKSB7XG4gICAgICAgIHJldHVybiBuZXdTdGF0ZShwcmV2X3N0b3JlLmN1bHR1cmUsIHByZXZfc3RvcmUuZmlyc3RfdmFsdWUsIGFjdGlvbi52YWx1ZSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBzdGF0ZVxuICAgICAgfVxuXG4gICAgY2FzZSAnU0hVRkZMRSc6XG4gICAgICBsZXQgcmFuZF9jdWx0ID0gcmFuZG9tQ3VsdHVyZSgpO1xuICAgICAgcmV0dXJuIG5ld1N0YXRlKHJhbmRfY3VsdCwgcmFuZG9tVmFsdWUocmFuZF9jdWx0KSwgcmFuZG9tVmFsdWUocmFuZF9jdWx0KSlcblxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gc3RhdGU7XG4gIH1cbn1cblxuLy8gdXBkYXRlcyBiYWNrZ3JvdW5kIGNvbG9ycyBiYXNlZCBvbiB0aGUgY3VycmVudCBzdGF0ZVxuZnVuY3Rpb24gdXBkYXRlQmFja2dyb3VuZEdyYWRpZW50KCkge1xuICBsZXQgY3Vycl9zdGF0ZSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gIGxldCBjdXJyX2N1bHR1cmUgPSBjdXJyX3N0YXRlLmN1bHR1cmU7XG4gIGxldCBmaXJzdF92YWx1ZSA9IGN1cnJfc3RhdGUuZmlyc3RfdmFsdWU7XG4gIGxldCBzZWNvbmRfdmFsdWUgPSBjdXJyX3N0YXRlLnNlY29uZF92YWx1ZTtcbiAgbGV0IGxlZnRfY29sb3IgPSBjdWx0dXJlc1tjdXJyX2N1bHR1cmVdW2ZpcnN0X3ZhbHVlXTtcbiAgbGV0IHJpZ2h0X2NvbG9yID0gY3VsdHVyZXNbY3Vycl9jdWx0dXJlXVtzZWNvbmRfdmFsdWVdO1xuICBsZXQgbGluZWFyX2dyYWRpZW50ID0gJ2xpbmVhci1ncmFkaWVudCh0byByaWdodCwnK2xlZnRfY29sb3IrJywnK3JpZ2h0X2NvbG9yKycpJztcbiAgZG9jdW1lbnQuYm9keS5zdHlsZS5iYWNrZ3JvdW5kID0gbGluZWFyX2dyYWRpZW50O1xufVxuXG4vLyB1cGRhdGVzIEN1bHR1cmUgYW5kIFZhbHVlcyBzZWxlY3QgdGFncyB0byBtYXRjaCB1c2VyJ3MgY2hvaWNlXG5mdW5jdGlvbiBzeW5jaHJvbml6ZVNlbGVjdElucHV0cygpIHtcbiAgbGV0IHN0YXRlID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgbGV0IGN1cnJfY3VsdHVyZV9rZXlzID0gT2JqZWN0LmtleXMoY3VsdHVyZXNbc3RhdGUuY3VsdHVyZV0pO1xuICBzZWxlY3RfZmlyc3RfdmFsdWUuc2VsZWN0ZWRJbmRleCA9IGN1cnJfY3VsdHVyZV9rZXlzLmluZGV4T2Yoc3RhdGUuZmlyc3RfdmFsdWUpO1xuICBzZWxlY3Rfc2Vjb25kX3ZhbHVlLnNlbGVjdGVkSW5kZXggPSBjdXJyX2N1bHR1cmVfa2V5cy5pbmRleE9mKHN0YXRlLnNlY29uZF92YWx1ZSk7XG4gIHNlbGVjdF9jdWx0dXJlLnNlbGVjdGVkSW5kZXggPSBjdWx0dXJlc19saXN0LmluZGV4T2Yoc3RvcmUuZ2V0U3RhdGUoKS5jdWx0dXJlKTtcbn1cblxuLy8gY2xlYXIgVmFsdWVzIGFuZCBuZXcgb3B0aW9ucyBiYXNlZCBvbiBjdXJyZW50IEN1bHR1cmVcbmZ1bmN0aW9uIHBvcHVsYXRlT3B0aW9ucygpIHtcbiAgc2VsZWN0X2ZpcnN0X3ZhbHVlLmlubmVySFRNTCA9IHNlbGVjdF9zZWNvbmRfdmFsdWUuaW5uZXJIVE1MID0gJyc7XG4gIGxldCBzdGF0ZSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gIGxldCBjdXJyX2N1bHR1cmVfa2V5cyA9IE9iamVjdC5rZXlzKGN1bHR1cmVzW3N0YXRlLmN1bHR1cmVdKTtcbiAgY3Vycl9jdWx0dXJlX2tleXMuZm9yRWFjaChhZGRfb3B0aW9uX3ZhbHVlX3RvX3NlbGVjdClcbn1cblxuLy8gYWRkcyBhIFZhbHVlIG9wdGlvbiB0byBib3RoIHNlbGVjdCBpbnB1dHNcbmZ1bmN0aW9uIGFkZF9vcHRpb25fdmFsdWVfdG9fc2VsZWN0KHZhbHVlKSB7XG4gIHNlbGVjdF9maXJzdF92YWx1ZS5hZGQob3B0aW9uX2NvbnN0cnVjdG9yKHZhbHVlKSk7XG4gIHNlbGVjdF9zZWNvbmRfdmFsdWUuYWRkKG9wdGlvbl9jb25zdHJ1Y3Rvcih2YWx1ZSkpO1xufVxuXG4vLyBjb25zdHJ1Y3RzIGFuIG9wdGlvbiBlbGVtZW50IGdpdmVuIGEgVmFsdWVcbmZ1bmN0aW9uIG9wdGlvbl9jb25zdHJ1Y3Rvcih2YWx1ZSkge1xuICBsZXQgb3B0aW9uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcIm9wdGlvblwiKTtcbiAgb3B0aW9uLnRleHQgPSB2YWx1ZTtcbiAgb3B0aW9uLm5vZGVWYWx1ZSA9IHZhbHVlO1xuICByZXR1cm4gb3B0aW9uXG59XG5cbi8vIHBvcHVsYXRlcyB0aGUgQ3VsdHVyZSBpbnB1dCB3aXRoIG9wdGlvbnNcbmZ1bmN0aW9uIHBvcHVsYXRlQ3VsdHVyZXMoKSB7XG4gIHNlbGVjdF9jdWx0dXJlLmlubmVySFRNTCA9ICcnO1xuICBjdWx0dXJlc19saXN0LmZvckVhY2goZnVuY3Rpb24oY3VsdHVyZSkge1xuICAgIHNlbGVjdF9jdWx0dXJlLmFkZChvcHRpb25fY29uc3RydWN0b3IoY3VsdHVyZSkpO1xuICB9KTtcbn1cblxuLy8gaGFuZGxlciBmb3IgbGVmdC9yaWdodCBWYWx1ZXMsIGRpc3BhdGNoZXMgYWN0aW9uIGZvciB2YWx1ZSBjaGFuZ2VcbmZ1bmN0aW9uIHZhbHVlU2VsZWN0SGFuZGxlcihldmVudCkge1xuICBsZXQgU0lERSA9IChldmVudC50YXJnZXQuaWQgPT09ICdmaXJzdF92YWx1ZScpID8gJ0xFRlQnIDogJ1JJR0hUJztcbiAgc3RvcmUuZGlzcGF0Y2goe1xuICAgIHR5cGU6ICdWQUxVRV9DSEFOR0UnLFxuICAgIHNpZGU6IFNJREUsXG4gICAgdmFsdWU6IGV2ZW50LnRhcmdldC52YWx1ZVxuICB9KTtcbn1cblxuLy8gaGFuZGxlciBmb3IgbGVmdC9yaWdodCBWYWx1ZXMsIGRpc3BhdGNoZXMgYWN0aW9uIGZvciBjdWx0dXJlIGNoYW5nZVxuZnVuY3Rpb24gY3VsdHVyZVNlbGVjdEhhbmRsZXIoZXZlbnQpIHtcbiAgc3RvcmUuZGlzcGF0Y2goe1xuICAgIHR5cGU6ICdDVUxUVVJFX0NIQU5HRScsXG4gICAgY3VsdHVyZTogZXZlbnQudGFyZ2V0LnZhbHVlXG4gIH0pO1xufVxuXG4vLyBoYW5kbGVyIGZvciBzaHVmZmxlIGJ1dHRvbiwgc2h1ZmZsZXMgc3RhdGVcbmZ1bmN0aW9uIGRpc3BhdGNoU2h1ZmZsZShlKSB7XG4gIHN0b3JlLmRpc3BhdGNoKHt0eXBlOiAnU0hVRkZMRSd9KTtcbn1cblxuLy8gcmV0dXJucyBhIHJhbmRvbSBWYWx1ZSBnaXZlbiBhIEN1bHR1cmVcbmZ1bmN0aW9uIHJhbmRvbVZhbHVlKGN1bHR1cmUpIHtcbiAgbGV0IGN1bHR1cmVfa2V5cyA9IE9iamVjdC5rZXlzKGN1bHR1cmVzW2N1bHR1cmVdKTtcbiAgbGV0IHJhbmRfa2V5ID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogY3VsdHVyZV9rZXlzLmxlbmd0aCk7XG4gIHJldHVybiBjdWx0dXJlX2tleXNbcmFuZF9rZXldO1xufVxuXG4vLyByZXR1cm5zIGEgcmFuZG9tIEN1bHR1cmVcbmZ1bmN0aW9uIHJhbmRvbUN1bHR1cmUoKSB7XG4gIGxldCByYW5kX2tleSA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIGN1bHR1cmVzX2xpc3QubGVuZ3RoKTtcbiAgcmV0dXJuIGN1bHR1cmVzX2xpc3RbcmFuZF9rZXldO1xufVxuXG4vLyBvYmplY3QgbG9va3VwIGZvciBjdXJyZW50IHN0YXRlJ3MgaGV4IHZhbHVlcywgcmVuZGVycy91cGRhdGVzIHRvIERPTVxuZnVuY3Rpb24gdXBkYXRlQ3VycmVudEhleFRvRE9NKCkge1xuICBsZXQgY3Vycl9zdGF0ZSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gIGxldCBsZWZ0X2NvbG9yID0gY3VsdHVyZXNbY3Vycl9zdGF0ZS5jdWx0dXJlXVtjdXJyX3N0YXRlLmZpcnN0X3ZhbHVlXTtcbiAgbGV0IHJpZ2h0X2NvbG9yID0gY3VsdHVyZXNbY3Vycl9zdGF0ZS5jdWx0dXJlXVtjdXJyX3N0YXRlLnNlY29uZF92YWx1ZV07XG4gIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdsZWZ0X2NvbG9yX2hleCcpLmlubmVyVGV4dCA9IGxlZnRfY29sb3I7XG4gIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdyaWdodF9jb2xvcl9oZXgnKS5pbm5lclRleHQgPSByaWdodF9jb2xvcjtcbn1cblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vbWFpbi5qc1xuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmV4cG9ydHMuY29tcG9zZSA9IGV4cG9ydHMuYXBwbHlNaWRkbGV3YXJlID0gZXhwb3J0cy5iaW5kQWN0aW9uQ3JlYXRvcnMgPSBleHBvcnRzLmNvbWJpbmVSZWR1Y2VycyA9IGV4cG9ydHMuY3JlYXRlU3RvcmUgPSB1bmRlZmluZWQ7XG5cbnZhciBfY3JlYXRlU3RvcmUgPSByZXF1aXJlKCcuL2NyZWF0ZVN0b3JlJyk7XG5cbnZhciBfY3JlYXRlU3RvcmUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY3JlYXRlU3RvcmUpO1xuXG52YXIgX2NvbWJpbmVSZWR1Y2VycyA9IHJlcXVpcmUoJy4vY29tYmluZVJlZHVjZXJzJyk7XG5cbnZhciBfY29tYmluZVJlZHVjZXJzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NvbWJpbmVSZWR1Y2Vycyk7XG5cbnZhciBfYmluZEFjdGlvbkNyZWF0b3JzID0gcmVxdWlyZSgnLi9iaW5kQWN0aW9uQ3JlYXRvcnMnKTtcblxudmFyIF9iaW5kQWN0aW9uQ3JlYXRvcnMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfYmluZEFjdGlvbkNyZWF0b3JzKTtcblxudmFyIF9hcHBseU1pZGRsZXdhcmUgPSByZXF1aXJlKCcuL2FwcGx5TWlkZGxld2FyZScpO1xuXG52YXIgX2FwcGx5TWlkZGxld2FyZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9hcHBseU1pZGRsZXdhcmUpO1xuXG52YXIgX2NvbXBvc2UgPSByZXF1aXJlKCcuL2NvbXBvc2UnKTtcblxudmFyIF9jb21wb3NlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NvbXBvc2UpO1xuXG52YXIgX3dhcm5pbmcgPSByZXF1aXJlKCcuL3V0aWxzL3dhcm5pbmcnKTtcblxudmFyIF93YXJuaW5nMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3dhcm5pbmcpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBcImRlZmF1bHRcIjogb2JqIH07IH1cblxuLypcbiogVGhpcyBpcyBhIGR1bW15IGZ1bmN0aW9uIHRvIGNoZWNrIGlmIHRoZSBmdW5jdGlvbiBuYW1lIGhhcyBiZWVuIGFsdGVyZWQgYnkgbWluaWZpY2F0aW9uLlxuKiBJZiB0aGUgZnVuY3Rpb24gaGFzIGJlZW4gbWluaWZpZWQgYW5kIE5PREVfRU5WICE9PSAncHJvZHVjdGlvbicsIHdhcm4gdGhlIHVzZXIuXG4qL1xuZnVuY3Rpb24gaXNDcnVzaGVkKCkge31cblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgdHlwZW9mIGlzQ3J1c2hlZC5uYW1lID09PSAnc3RyaW5nJyAmJiBpc0NydXNoZWQubmFtZSAhPT0gJ2lzQ3J1c2hlZCcpIHtcbiAgKDAsIF93YXJuaW5nMltcImRlZmF1bHRcIl0pKCdZb3UgYXJlIGN1cnJlbnRseSB1c2luZyBtaW5pZmllZCBjb2RlIG91dHNpZGUgb2YgTk9ERV9FTlYgPT09IFxcJ3Byb2R1Y3Rpb25cXCcuICcgKyAnVGhpcyBtZWFucyB0aGF0IHlvdSBhcmUgcnVubmluZyBhIHNsb3dlciBkZXZlbG9wbWVudCBidWlsZCBvZiBSZWR1eC4gJyArICdZb3UgY2FuIHVzZSBsb29zZS1lbnZpZnkgKGh0dHBzOi8vZ2l0aHViLmNvbS96ZXJ0b3NoL2xvb3NlLWVudmlmeSkgZm9yIGJyb3dzZXJpZnkgJyArICdvciBEZWZpbmVQbHVnaW4gZm9yIHdlYnBhY2sgKGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMzAwMzAwMzEpICcgKyAndG8gZW5zdXJlIHlvdSBoYXZlIHRoZSBjb3JyZWN0IGNvZGUgZm9yIHlvdXIgcHJvZHVjdGlvbiBidWlsZC4nKTtcbn1cblxuZXhwb3J0cy5jcmVhdGVTdG9yZSA9IF9jcmVhdGVTdG9yZTJbXCJkZWZhdWx0XCJdO1xuZXhwb3J0cy5jb21iaW5lUmVkdWNlcnMgPSBfY29tYmluZVJlZHVjZXJzMltcImRlZmF1bHRcIl07XG5leHBvcnRzLmJpbmRBY3Rpb25DcmVhdG9ycyA9IF9iaW5kQWN0aW9uQ3JlYXRvcnMyW1wiZGVmYXVsdFwiXTtcbmV4cG9ydHMuYXBwbHlNaWRkbGV3YXJlID0gX2FwcGx5TWlkZGxld2FyZTJbXCJkZWZhdWx0XCJdO1xuZXhwb3J0cy5jb21wb3NlID0gX2NvbXBvc2UyW1wiZGVmYXVsdFwiXTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4uL34vcmVkdXgvbGliL2luZGV4LmpzXG4gKiogbW9kdWxlIGlkID0gMVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gc2hpbSBmb3IgdXNpbmcgcHJvY2VzcyBpbiBicm93c2VyXG5cbnZhciBwcm9jZXNzID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcblxuLy8gY2FjaGVkIGZyb20gd2hhdGV2ZXIgZ2xvYmFsIGlzIHByZXNlbnQgc28gdGhhdCB0ZXN0IHJ1bm5lcnMgdGhhdCBzdHViIGl0XG4vLyBkb24ndCBicmVhayB0aGluZ3MuICBCdXQgd2UgbmVlZCB0byB3cmFwIGl0IGluIGEgdHJ5IGNhdGNoIGluIGNhc2UgaXQgaXNcbi8vIHdyYXBwZWQgaW4gc3RyaWN0IG1vZGUgY29kZSB3aGljaCBkb2Vzbid0IGRlZmluZSBhbnkgZ2xvYmFscy4gIEl0J3MgaW5zaWRlIGFcbi8vIGZ1bmN0aW9uIGJlY2F1c2UgdHJ5L2NhdGNoZXMgZGVvcHRpbWl6ZSBpbiBjZXJ0YWluIGVuZ2luZXMuXG5cbnZhciBjYWNoZWRTZXRUaW1lb3V0O1xudmFyIGNhY2hlZENsZWFyVGltZW91dDtcblxuKGZ1bmN0aW9uICgpIHtcbiAgdHJ5IHtcbiAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgfSBjYXRjaCAoZSkge1xuICAgIGNhY2hlZFNldFRpbWVvdXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3NldFRpbWVvdXQgaXMgbm90IGRlZmluZWQnKTtcbiAgICB9XG4gIH1cbiAgdHJ5IHtcbiAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NsZWFyVGltZW91dCBpcyBub3QgZGVmaW5lZCcpO1xuICAgIH1cbiAgfVxufSAoKSlcbnZhciBxdWV1ZSA9IFtdO1xudmFyIGRyYWluaW5nID0gZmFsc2U7XG52YXIgY3VycmVudFF1ZXVlO1xudmFyIHF1ZXVlSW5kZXggPSAtMTtcblxuZnVuY3Rpb24gY2xlYW5VcE5leHRUaWNrKCkge1xuICAgIGlmICghZHJhaW5pbmcgfHwgIWN1cnJlbnRRdWV1ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgaWYgKGN1cnJlbnRRdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgcXVldWUgPSBjdXJyZW50UXVldWUuY29uY2F0KHF1ZXVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgfVxuICAgIGlmIChxdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgZHJhaW5RdWV1ZSgpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZHJhaW5RdWV1ZSgpIHtcbiAgICBpZiAoZHJhaW5pbmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgdGltZW91dCA9IGNhY2hlZFNldFRpbWVvdXQoY2xlYW5VcE5leHRUaWNrKTtcbiAgICBkcmFpbmluZyA9IHRydWU7XG5cbiAgICB2YXIgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIHdoaWxlKGxlbikge1xuICAgICAgICBjdXJyZW50UXVldWUgPSBxdWV1ZTtcbiAgICAgICAgcXVldWUgPSBbXTtcbiAgICAgICAgd2hpbGUgKCsrcXVldWVJbmRleCA8IGxlbikge1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRRdWV1ZSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRRdWV1ZVtxdWV1ZUluZGV4XS5ydW4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgICAgIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB9XG4gICAgY3VycmVudFF1ZXVlID0gbnVsbDtcbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIGNhY2hlZENsZWFyVGltZW91dCh0aW1lb3V0KTtcbn1cblxucHJvY2Vzcy5uZXh0VGljayA9IGZ1bmN0aW9uIChmdW4pIHtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSk7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBxdWV1ZS5wdXNoKG5ldyBJdGVtKGZ1biwgYXJncykpO1xuICAgIGlmIChxdWV1ZS5sZW5ndGggPT09IDEgJiYgIWRyYWluaW5nKSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQoZHJhaW5RdWV1ZSwgMCk7XG4gICAgfVxufTtcblxuLy8gdjggbGlrZXMgcHJlZGljdGlibGUgb2JqZWN0c1xuZnVuY3Rpb24gSXRlbShmdW4sIGFycmF5KSB7XG4gICAgdGhpcy5mdW4gPSBmdW47XG4gICAgdGhpcy5hcnJheSA9IGFycmF5O1xufVxuSXRlbS5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZnVuLmFwcGx5KG51bGwsIHRoaXMuYXJyYXkpO1xufTtcbnByb2Nlc3MudGl0bGUgPSAnYnJvd3Nlcic7XG5wcm9jZXNzLmJyb3dzZXIgPSB0cnVlO1xucHJvY2Vzcy5lbnYgPSB7fTtcbnByb2Nlc3MuYXJndiA9IFtdO1xucHJvY2Vzcy52ZXJzaW9uID0gJyc7IC8vIGVtcHR5IHN0cmluZyB0byBhdm9pZCByZWdleHAgaXNzdWVzXG5wcm9jZXNzLnZlcnNpb25zID0ge307XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG5wcm9jZXNzLm9uID0gbm9vcDtcbnByb2Nlc3MuYWRkTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5vbmNlID0gbm9vcDtcbnByb2Nlc3Mub2ZmID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBub29wO1xucHJvY2Vzcy5lbWl0ID0gbm9vcDtcblxucHJvY2Vzcy5iaW5kaW5nID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuYmluZGluZyBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xuXG5wcm9jZXNzLmN3ZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICcvJyB9O1xucHJvY2Vzcy5jaGRpciA9IGZ1bmN0aW9uIChkaXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuY2hkaXIgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcbnByb2Nlc3MudW1hc2sgPSBmdW5jdGlvbigpIHsgcmV0dXJuIDA7IH07XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4uL34vcHJvY2Vzcy9icm93c2VyLmpzXG4gKiogbW9kdWxlIGlkID0gMlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuZXhwb3J0cy5BY3Rpb25UeXBlcyA9IHVuZGVmaW5lZDtcbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gY3JlYXRlU3RvcmU7XG5cbnZhciBfaXNQbGFpbk9iamVjdCA9IHJlcXVpcmUoJ2xvZGFzaC9pc1BsYWluT2JqZWN0Jyk7XG5cbnZhciBfaXNQbGFpbk9iamVjdDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9pc1BsYWluT2JqZWN0KTtcblxudmFyIF9zeW1ib2xPYnNlcnZhYmxlID0gcmVxdWlyZSgnc3ltYm9sLW9ic2VydmFibGUnKTtcblxudmFyIF9zeW1ib2xPYnNlcnZhYmxlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3N5bWJvbE9ic2VydmFibGUpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBcImRlZmF1bHRcIjogb2JqIH07IH1cblxuLyoqXG4gKiBUaGVzZSBhcmUgcHJpdmF0ZSBhY3Rpb24gdHlwZXMgcmVzZXJ2ZWQgYnkgUmVkdXguXG4gKiBGb3IgYW55IHVua25vd24gYWN0aW9ucywgeW91IG11c3QgcmV0dXJuIHRoZSBjdXJyZW50IHN0YXRlLlxuICogSWYgdGhlIGN1cnJlbnQgc3RhdGUgaXMgdW5kZWZpbmVkLCB5b3UgbXVzdCByZXR1cm4gdGhlIGluaXRpYWwgc3RhdGUuXG4gKiBEbyBub3QgcmVmZXJlbmNlIHRoZXNlIGFjdGlvbiB0eXBlcyBkaXJlY3RseSBpbiB5b3VyIGNvZGUuXG4gKi9cbnZhciBBY3Rpb25UeXBlcyA9IGV4cG9ydHMuQWN0aW9uVHlwZXMgPSB7XG4gIElOSVQ6ICdAQHJlZHV4L0lOSVQnXG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBSZWR1eCBzdG9yZSB0aGF0IGhvbGRzIHRoZSBzdGF0ZSB0cmVlLlxuICogVGhlIG9ubHkgd2F5IHRvIGNoYW5nZSB0aGUgZGF0YSBpbiB0aGUgc3RvcmUgaXMgdG8gY2FsbCBgZGlzcGF0Y2goKWAgb24gaXQuXG4gKlxuICogVGhlcmUgc2hvdWxkIG9ubHkgYmUgYSBzaW5nbGUgc3RvcmUgaW4geW91ciBhcHAuIFRvIHNwZWNpZnkgaG93IGRpZmZlcmVudFxuICogcGFydHMgb2YgdGhlIHN0YXRlIHRyZWUgcmVzcG9uZCB0byBhY3Rpb25zLCB5b3UgbWF5IGNvbWJpbmUgc2V2ZXJhbCByZWR1Y2Vyc1xuICogaW50byBhIHNpbmdsZSByZWR1Y2VyIGZ1bmN0aW9uIGJ5IHVzaW5nIGBjb21iaW5lUmVkdWNlcnNgLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IHJlZHVjZXIgQSBmdW5jdGlvbiB0aGF0IHJldHVybnMgdGhlIG5leHQgc3RhdGUgdHJlZSwgZ2l2ZW5cbiAqIHRoZSBjdXJyZW50IHN0YXRlIHRyZWUgYW5kIHRoZSBhY3Rpb24gdG8gaGFuZGxlLlxuICpcbiAqIEBwYXJhbSB7YW55fSBbaW5pdGlhbFN0YXRlXSBUaGUgaW5pdGlhbCBzdGF0ZS4gWW91IG1heSBvcHRpb25hbGx5IHNwZWNpZnkgaXRcbiAqIHRvIGh5ZHJhdGUgdGhlIHN0YXRlIGZyb20gdGhlIHNlcnZlciBpbiB1bml2ZXJzYWwgYXBwcywgb3IgdG8gcmVzdG9yZSBhXG4gKiBwcmV2aW91c2x5IHNlcmlhbGl6ZWQgdXNlciBzZXNzaW9uLlxuICogSWYgeW91IHVzZSBgY29tYmluZVJlZHVjZXJzYCB0byBwcm9kdWNlIHRoZSByb290IHJlZHVjZXIgZnVuY3Rpb24sIHRoaXMgbXVzdCBiZVxuICogYW4gb2JqZWN0IHdpdGggdGhlIHNhbWUgc2hhcGUgYXMgYGNvbWJpbmVSZWR1Y2Vyc2Aga2V5cy5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBlbmhhbmNlciBUaGUgc3RvcmUgZW5oYW5jZXIuIFlvdSBtYXkgb3B0aW9uYWxseSBzcGVjaWZ5IGl0XG4gKiB0byBlbmhhbmNlIHRoZSBzdG9yZSB3aXRoIHRoaXJkLXBhcnR5IGNhcGFiaWxpdGllcyBzdWNoIGFzIG1pZGRsZXdhcmUsXG4gKiB0aW1lIHRyYXZlbCwgcGVyc2lzdGVuY2UsIGV0Yy4gVGhlIG9ubHkgc3RvcmUgZW5oYW5jZXIgdGhhdCBzaGlwcyB3aXRoIFJlZHV4XG4gKiBpcyBgYXBwbHlNaWRkbGV3YXJlKClgLlxuICpcbiAqIEByZXR1cm5zIHtTdG9yZX0gQSBSZWR1eCBzdG9yZSB0aGF0IGxldHMgeW91IHJlYWQgdGhlIHN0YXRlLCBkaXNwYXRjaCBhY3Rpb25zXG4gKiBhbmQgc3Vic2NyaWJlIHRvIGNoYW5nZXMuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVN0b3JlKHJlZHVjZXIsIGluaXRpYWxTdGF0ZSwgZW5oYW5jZXIpIHtcbiAgdmFyIF9yZWYyO1xuXG4gIGlmICh0eXBlb2YgaW5pdGlhbFN0YXRlID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBlbmhhbmNlciA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBlbmhhbmNlciA9IGluaXRpYWxTdGF0ZTtcbiAgICBpbml0aWFsU3RhdGUgPSB1bmRlZmluZWQ7XG4gIH1cblxuICBpZiAodHlwZW9mIGVuaGFuY2VyICE9PSAndW5kZWZpbmVkJykge1xuICAgIGlmICh0eXBlb2YgZW5oYW5jZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgdGhlIGVuaGFuY2VyIHRvIGJlIGEgZnVuY3Rpb24uJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGVuaGFuY2VyKGNyZWF0ZVN0b3JlKShyZWR1Y2VyLCBpbml0aWFsU3RhdGUpO1xuICB9XG5cbiAgaWYgKHR5cGVvZiByZWR1Y2VyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCB0aGUgcmVkdWNlciB0byBiZSBhIGZ1bmN0aW9uLicpO1xuICB9XG5cbiAgdmFyIGN1cnJlbnRSZWR1Y2VyID0gcmVkdWNlcjtcbiAgdmFyIGN1cnJlbnRTdGF0ZSA9IGluaXRpYWxTdGF0ZTtcbiAgdmFyIGN1cnJlbnRMaXN0ZW5lcnMgPSBbXTtcbiAgdmFyIG5leHRMaXN0ZW5lcnMgPSBjdXJyZW50TGlzdGVuZXJzO1xuICB2YXIgaXNEaXNwYXRjaGluZyA9IGZhbHNlO1xuXG4gIGZ1bmN0aW9uIGVuc3VyZUNhbk11dGF0ZU5leHRMaXN0ZW5lcnMoKSB7XG4gICAgaWYgKG5leHRMaXN0ZW5lcnMgPT09IGN1cnJlbnRMaXN0ZW5lcnMpIHtcbiAgICAgIG5leHRMaXN0ZW5lcnMgPSBjdXJyZW50TGlzdGVuZXJzLnNsaWNlKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJlYWRzIHRoZSBzdGF0ZSB0cmVlIG1hbmFnZWQgYnkgdGhlIHN0b3JlLlxuICAgKlxuICAgKiBAcmV0dXJucyB7YW55fSBUaGUgY3VycmVudCBzdGF0ZSB0cmVlIG9mIHlvdXIgYXBwbGljYXRpb24uXG4gICAqL1xuICBmdW5jdGlvbiBnZXRTdGF0ZSgpIHtcbiAgICByZXR1cm4gY3VycmVudFN0YXRlO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZHMgYSBjaGFuZ2UgbGlzdGVuZXIuIEl0IHdpbGwgYmUgY2FsbGVkIGFueSB0aW1lIGFuIGFjdGlvbiBpcyBkaXNwYXRjaGVkLFxuICAgKiBhbmQgc29tZSBwYXJ0IG9mIHRoZSBzdGF0ZSB0cmVlIG1heSBwb3RlbnRpYWxseSBoYXZlIGNoYW5nZWQuIFlvdSBtYXkgdGhlblxuICAgKiBjYWxsIGBnZXRTdGF0ZSgpYCB0byByZWFkIHRoZSBjdXJyZW50IHN0YXRlIHRyZWUgaW5zaWRlIHRoZSBjYWxsYmFjay5cbiAgICpcbiAgICogWW91IG1heSBjYWxsIGBkaXNwYXRjaCgpYCBmcm9tIGEgY2hhbmdlIGxpc3RlbmVyLCB3aXRoIHRoZSBmb2xsb3dpbmdcbiAgICogY2F2ZWF0czpcbiAgICpcbiAgICogMS4gVGhlIHN1YnNjcmlwdGlvbnMgYXJlIHNuYXBzaG90dGVkIGp1c3QgYmVmb3JlIGV2ZXJ5IGBkaXNwYXRjaCgpYCBjYWxsLlxuICAgKiBJZiB5b3Ugc3Vic2NyaWJlIG9yIHVuc3Vic2NyaWJlIHdoaWxlIHRoZSBsaXN0ZW5lcnMgYXJlIGJlaW5nIGludm9rZWQsIHRoaXNcbiAgICogd2lsbCBub3QgaGF2ZSBhbnkgZWZmZWN0IG9uIHRoZSBgZGlzcGF0Y2goKWAgdGhhdCBpcyBjdXJyZW50bHkgaW4gcHJvZ3Jlc3MuXG4gICAqIEhvd2V2ZXIsIHRoZSBuZXh0IGBkaXNwYXRjaCgpYCBjYWxsLCB3aGV0aGVyIG5lc3RlZCBvciBub3QsIHdpbGwgdXNlIGEgbW9yZVxuICAgKiByZWNlbnQgc25hcHNob3Qgb2YgdGhlIHN1YnNjcmlwdGlvbiBsaXN0LlxuICAgKlxuICAgKiAyLiBUaGUgbGlzdGVuZXIgc2hvdWxkIG5vdCBleHBlY3QgdG8gc2VlIGFsbCBzdGF0ZSBjaGFuZ2VzLCBhcyB0aGUgc3RhdGVcbiAgICogbWlnaHQgaGF2ZSBiZWVuIHVwZGF0ZWQgbXVsdGlwbGUgdGltZXMgZHVyaW5nIGEgbmVzdGVkIGBkaXNwYXRjaCgpYCBiZWZvcmVcbiAgICogdGhlIGxpc3RlbmVyIGlzIGNhbGxlZC4gSXQgaXMsIGhvd2V2ZXIsIGd1YXJhbnRlZWQgdGhhdCBhbGwgc3Vic2NyaWJlcnNcbiAgICogcmVnaXN0ZXJlZCBiZWZvcmUgdGhlIGBkaXNwYXRjaCgpYCBzdGFydGVkIHdpbGwgYmUgY2FsbGVkIHdpdGggdGhlIGxhdGVzdFxuICAgKiBzdGF0ZSBieSB0aGUgdGltZSBpdCBleGl0cy5cbiAgICpcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gbGlzdGVuZXIgQSBjYWxsYmFjayB0byBiZSBpbnZva2VkIG9uIGV2ZXJ5IGRpc3BhdGNoLlxuICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IEEgZnVuY3Rpb24gdG8gcmVtb3ZlIHRoaXMgY2hhbmdlIGxpc3RlbmVyLlxuICAgKi9cbiAgZnVuY3Rpb24gc3Vic2NyaWJlKGxpc3RlbmVyKSB7XG4gICAgaWYgKHR5cGVvZiBsaXN0ZW5lciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCBsaXN0ZW5lciB0byBiZSBhIGZ1bmN0aW9uLicpO1xuICAgIH1cblxuICAgIHZhciBpc1N1YnNjcmliZWQgPSB0cnVlO1xuXG4gICAgZW5zdXJlQ2FuTXV0YXRlTmV4dExpc3RlbmVycygpO1xuICAgIG5leHRMaXN0ZW5lcnMucHVzaChsaXN0ZW5lcik7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gdW5zdWJzY3JpYmUoKSB7XG4gICAgICBpZiAoIWlzU3Vic2NyaWJlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlzU3Vic2NyaWJlZCA9IGZhbHNlO1xuXG4gICAgICBlbnN1cmVDYW5NdXRhdGVOZXh0TGlzdGVuZXJzKCk7XG4gICAgICB2YXIgaW5kZXggPSBuZXh0TGlzdGVuZXJzLmluZGV4T2YobGlzdGVuZXIpO1xuICAgICAgbmV4dExpc3RlbmVycy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogRGlzcGF0Y2hlcyBhbiBhY3Rpb24uIEl0IGlzIHRoZSBvbmx5IHdheSB0byB0cmlnZ2VyIGEgc3RhdGUgY2hhbmdlLlxuICAgKlxuICAgKiBUaGUgYHJlZHVjZXJgIGZ1bmN0aW9uLCB1c2VkIHRvIGNyZWF0ZSB0aGUgc3RvcmUsIHdpbGwgYmUgY2FsbGVkIHdpdGggdGhlXG4gICAqIGN1cnJlbnQgc3RhdGUgdHJlZSBhbmQgdGhlIGdpdmVuIGBhY3Rpb25gLiBJdHMgcmV0dXJuIHZhbHVlIHdpbGxcbiAgICogYmUgY29uc2lkZXJlZCB0aGUgKipuZXh0Kiogc3RhdGUgb2YgdGhlIHRyZWUsIGFuZCB0aGUgY2hhbmdlIGxpc3RlbmVyc1xuICAgKiB3aWxsIGJlIG5vdGlmaWVkLlxuICAgKlxuICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvbmx5IHN1cHBvcnRzIHBsYWluIG9iamVjdCBhY3Rpb25zLiBJZiB5b3Ugd2FudCB0b1xuICAgKiBkaXNwYXRjaCBhIFByb21pc2UsIGFuIE9ic2VydmFibGUsIGEgdGh1bmssIG9yIHNvbWV0aGluZyBlbHNlLCB5b3UgbmVlZCB0b1xuICAgKiB3cmFwIHlvdXIgc3RvcmUgY3JlYXRpbmcgZnVuY3Rpb24gaW50byB0aGUgY29ycmVzcG9uZGluZyBtaWRkbGV3YXJlLiBGb3JcbiAgICogZXhhbXBsZSwgc2VlIHRoZSBkb2N1bWVudGF0aW9uIGZvciB0aGUgYHJlZHV4LXRodW5rYCBwYWNrYWdlLiBFdmVuIHRoZVxuICAgKiBtaWRkbGV3YXJlIHdpbGwgZXZlbnR1YWxseSBkaXNwYXRjaCBwbGFpbiBvYmplY3QgYWN0aW9ucyB1c2luZyB0aGlzIG1ldGhvZC5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IGFjdGlvbiBBIHBsYWluIG9iamVjdCByZXByZXNlbnRpbmcg4oCcd2hhdCBjaGFuZ2Vk4oCdLiBJdCBpc1xuICAgKiBhIGdvb2QgaWRlYSB0byBrZWVwIGFjdGlvbnMgc2VyaWFsaXphYmxlIHNvIHlvdSBjYW4gcmVjb3JkIGFuZCByZXBsYXkgdXNlclxuICAgKiBzZXNzaW9ucywgb3IgdXNlIHRoZSB0aW1lIHRyYXZlbGxpbmcgYHJlZHV4LWRldnRvb2xzYC4gQW4gYWN0aW9uIG11c3QgaGF2ZVxuICAgKiBhIGB0eXBlYCBwcm9wZXJ0eSB3aGljaCBtYXkgbm90IGJlIGB1bmRlZmluZWRgLiBJdCBpcyBhIGdvb2QgaWRlYSB0byB1c2VcbiAgICogc3RyaW5nIGNvbnN0YW50cyBmb3IgYWN0aW9uIHR5cGVzLlxuICAgKlxuICAgKiBAcmV0dXJucyB7T2JqZWN0fSBGb3IgY29udmVuaWVuY2UsIHRoZSBzYW1lIGFjdGlvbiBvYmplY3QgeW91IGRpc3BhdGNoZWQuXG4gICAqXG4gICAqIE5vdGUgdGhhdCwgaWYgeW91IHVzZSBhIGN1c3RvbSBtaWRkbGV3YXJlLCBpdCBtYXkgd3JhcCBgZGlzcGF0Y2goKWAgdG9cbiAgICogcmV0dXJuIHNvbWV0aGluZyBlbHNlIChmb3IgZXhhbXBsZSwgYSBQcm9taXNlIHlvdSBjYW4gYXdhaXQpLlxuICAgKi9cbiAgZnVuY3Rpb24gZGlzcGF0Y2goYWN0aW9uKSB7XG4gICAgaWYgKCEoMCwgX2lzUGxhaW5PYmplY3QyW1wiZGVmYXVsdFwiXSkoYWN0aW9uKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdBY3Rpb25zIG11c3QgYmUgcGxhaW4gb2JqZWN0cy4gJyArICdVc2UgY3VzdG9tIG1pZGRsZXdhcmUgZm9yIGFzeW5jIGFjdGlvbnMuJyk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBhY3Rpb24udHlwZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQWN0aW9ucyBtYXkgbm90IGhhdmUgYW4gdW5kZWZpbmVkIFwidHlwZVwiIHByb3BlcnR5LiAnICsgJ0hhdmUgeW91IG1pc3NwZWxsZWQgYSBjb25zdGFudD8nKTtcbiAgICB9XG5cbiAgICBpZiAoaXNEaXNwYXRjaGluZykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdSZWR1Y2VycyBtYXkgbm90IGRpc3BhdGNoIGFjdGlvbnMuJyk7XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIGlzRGlzcGF0Y2hpbmcgPSB0cnVlO1xuICAgICAgY3VycmVudFN0YXRlID0gY3VycmVudFJlZHVjZXIoY3VycmVudFN0YXRlLCBhY3Rpb24pO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBpc0Rpc3BhdGNoaW5nID0gZmFsc2U7XG4gICAgfVxuXG4gICAgdmFyIGxpc3RlbmVycyA9IGN1cnJlbnRMaXN0ZW5lcnMgPSBuZXh0TGlzdGVuZXJzO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdGVuZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBsaXN0ZW5lcnNbaV0oKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYWN0aW9uO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlcGxhY2VzIHRoZSByZWR1Y2VyIGN1cnJlbnRseSB1c2VkIGJ5IHRoZSBzdG9yZSB0byBjYWxjdWxhdGUgdGhlIHN0YXRlLlxuICAgKlxuICAgKiBZb3UgbWlnaHQgbmVlZCB0aGlzIGlmIHlvdXIgYXBwIGltcGxlbWVudHMgY29kZSBzcGxpdHRpbmcgYW5kIHlvdSB3YW50IHRvXG4gICAqIGxvYWQgc29tZSBvZiB0aGUgcmVkdWNlcnMgZHluYW1pY2FsbHkuIFlvdSBtaWdodCBhbHNvIG5lZWQgdGhpcyBpZiB5b3VcbiAgICogaW1wbGVtZW50IGEgaG90IHJlbG9hZGluZyBtZWNoYW5pc20gZm9yIFJlZHV4LlxuICAgKlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBuZXh0UmVkdWNlciBUaGUgcmVkdWNlciBmb3IgdGhlIHN0b3JlIHRvIHVzZSBpbnN0ZWFkLlxuICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICovXG4gIGZ1bmN0aW9uIHJlcGxhY2VSZWR1Y2VyKG5leHRSZWR1Y2VyKSB7XG4gICAgaWYgKHR5cGVvZiBuZXh0UmVkdWNlciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCB0aGUgbmV4dFJlZHVjZXIgdG8gYmUgYSBmdW5jdGlvbi4nKTtcbiAgICB9XG5cbiAgICBjdXJyZW50UmVkdWNlciA9IG5leHRSZWR1Y2VyO1xuICAgIGRpc3BhdGNoKHsgdHlwZTogQWN0aW9uVHlwZXMuSU5JVCB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbnRlcm9wZXJhYmlsaXR5IHBvaW50IGZvciBvYnNlcnZhYmxlL3JlYWN0aXZlIGxpYnJhcmllcy5cbiAgICogQHJldHVybnMge29ic2VydmFibGV9IEEgbWluaW1hbCBvYnNlcnZhYmxlIG9mIHN0YXRlIGNoYW5nZXMuXG4gICAqIEZvciBtb3JlIGluZm9ybWF0aW9uLCBzZWUgdGhlIG9ic2VydmFibGUgcHJvcG9zYWw6XG4gICAqIGh0dHBzOi8vZ2l0aHViLmNvbS96ZW5wYXJzaW5nL2VzLW9ic2VydmFibGVcbiAgICovXG4gIGZ1bmN0aW9uIG9ic2VydmFibGUoKSB7XG4gICAgdmFyIF9yZWY7XG5cbiAgICB2YXIgb3V0ZXJTdWJzY3JpYmUgPSBzdWJzY3JpYmU7XG4gICAgcmV0dXJuIF9yZWYgPSB7XG4gICAgICAvKipcbiAgICAgICAqIFRoZSBtaW5pbWFsIG9ic2VydmFibGUgc3Vic2NyaXB0aW9uIG1ldGhvZC5cbiAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYnNlcnZlciBBbnkgb2JqZWN0IHRoYXQgY2FuIGJlIHVzZWQgYXMgYW4gb2JzZXJ2ZXIuXG4gICAgICAgKiBUaGUgb2JzZXJ2ZXIgb2JqZWN0IHNob3VsZCBoYXZlIGEgYG5leHRgIG1ldGhvZC5cbiAgICAgICAqIEByZXR1cm5zIHtzdWJzY3JpcHRpb259IEFuIG9iamVjdCB3aXRoIGFuIGB1bnN1YnNjcmliZWAgbWV0aG9kIHRoYXQgY2FuXG4gICAgICAgKiBiZSB1c2VkIHRvIHVuc3Vic2NyaWJlIHRoZSBvYnNlcnZhYmxlIGZyb20gdGhlIHN0b3JlLCBhbmQgcHJldmVudCBmdXJ0aGVyXG4gICAgICAgKiBlbWlzc2lvbiBvZiB2YWx1ZXMgZnJvbSB0aGUgb2JzZXJ2YWJsZS5cbiAgICAgICAqL1xuXG4gICAgICBzdWJzY3JpYmU6IGZ1bmN0aW9uIHN1YnNjcmliZShvYnNlcnZlcikge1xuICAgICAgICBpZiAodHlwZW9mIG9ic2VydmVyICE9PSAnb2JqZWN0Jykge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0V4cGVjdGVkIHRoZSBvYnNlcnZlciB0byBiZSBhbiBvYmplY3QuJyk7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBvYnNlcnZlU3RhdGUoKSB7XG4gICAgICAgICAgaWYgKG9ic2VydmVyLm5leHQpIHtcbiAgICAgICAgICAgIG9ic2VydmVyLm5leHQoZ2V0U3RhdGUoKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgb2JzZXJ2ZVN0YXRlKCk7XG4gICAgICAgIHZhciB1bnN1YnNjcmliZSA9IG91dGVyU3Vic2NyaWJlKG9ic2VydmVTdGF0ZSk7XG4gICAgICAgIHJldHVybiB7IHVuc3Vic2NyaWJlOiB1bnN1YnNjcmliZSB9O1xuICAgICAgfVxuICAgIH0sIF9yZWZbX3N5bWJvbE9ic2VydmFibGUyW1wiZGVmYXVsdFwiXV0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LCBfcmVmO1xuICB9XG5cbiAgLy8gV2hlbiBhIHN0b3JlIGlzIGNyZWF0ZWQsIGFuIFwiSU5JVFwiIGFjdGlvbiBpcyBkaXNwYXRjaGVkIHNvIHRoYXQgZXZlcnlcbiAgLy8gcmVkdWNlciByZXR1cm5zIHRoZWlyIGluaXRpYWwgc3RhdGUuIFRoaXMgZWZmZWN0aXZlbHkgcG9wdWxhdGVzXG4gIC8vIHRoZSBpbml0aWFsIHN0YXRlIHRyZWUuXG4gIGRpc3BhdGNoKHsgdHlwZTogQWN0aW9uVHlwZXMuSU5JVCB9KTtcblxuICByZXR1cm4gX3JlZjIgPSB7XG4gICAgZGlzcGF0Y2g6IGRpc3BhdGNoLFxuICAgIHN1YnNjcmliZTogc3Vic2NyaWJlLFxuICAgIGdldFN0YXRlOiBnZXRTdGF0ZSxcbiAgICByZXBsYWNlUmVkdWNlcjogcmVwbGFjZVJlZHVjZXJcbiAgfSwgX3JlZjJbX3N5bWJvbE9ic2VydmFibGUyW1wiZGVmYXVsdFwiXV0gPSBvYnNlcnZhYmxlLCBfcmVmMjtcbn1cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4uL34vcmVkdXgvbGliL2NyZWF0ZVN0b3JlLmpzXG4gKiogbW9kdWxlIGlkID0gM1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIGdldFByb3RvdHlwZSA9IHJlcXVpcmUoJy4vX2dldFByb3RvdHlwZScpLFxuICAgIGlzSG9zdE9iamVjdCA9IHJlcXVpcmUoJy4vX2lzSG9zdE9iamVjdCcpLFxuICAgIGlzT2JqZWN0TGlrZSA9IHJlcXVpcmUoJy4vaXNPYmplY3RMaWtlJyk7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RUYWcgPSAnW29iamVjdCBPYmplY3RdJztcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gcmVzb2x2ZSB0aGUgZGVjb21waWxlZCBzb3VyY2Ugb2YgZnVuY3Rpb25zLiAqL1xudmFyIGZ1bmNUb1N0cmluZyA9IEZ1bmN0aW9uLnByb3RvdHlwZS50b1N0cmluZztcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqIFVzZWQgdG8gaW5mZXIgdGhlIGBPYmplY3RgIGNvbnN0cnVjdG9yLiAqL1xudmFyIG9iamVjdEN0b3JTdHJpbmcgPSBmdW5jVG9TdHJpbmcuY2FsbChPYmplY3QpO1xuXG4vKipcbiAqIFVzZWQgdG8gcmVzb2x2ZSB0aGVcbiAqIFtgdG9TdHJpbmdUYWdgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi82LjAvI3NlYy1vYmplY3QucHJvdG90eXBlLnRvc3RyaW5nKVxuICogb2YgdmFsdWVzLlxuICovXG52YXIgb2JqZWN0VG9TdHJpbmcgPSBvYmplY3RQcm90by50b1N0cmluZztcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHBsYWluIG9iamVjdCwgdGhhdCBpcywgYW4gb2JqZWN0IGNyZWF0ZWQgYnkgdGhlXG4gKiBgT2JqZWN0YCBjb25zdHJ1Y3RvciBvciBvbmUgd2l0aCBhIGBbW1Byb3RvdHlwZV1dYCBvZiBgbnVsbGAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjguMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBwbGFpbiBvYmplY3QsXG4gKiAgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBmdW5jdGlvbiBGb28oKSB7XG4gKiAgIHRoaXMuYSA9IDE7XG4gKiB9XG4gKlxuICogXy5pc1BsYWluT2JqZWN0KG5ldyBGb28pO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzUGxhaW5PYmplY3QoWzEsIDIsIDNdKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc1BsYWluT2JqZWN0KHsgJ3gnOiAwLCAneSc6IDAgfSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc1BsYWluT2JqZWN0KE9iamVjdC5jcmVhdGUobnVsbCkpO1xuICogLy8gPT4gdHJ1ZVxuICovXG5mdW5jdGlvbiBpc1BsYWluT2JqZWN0KHZhbHVlKSB7XG4gIGlmICghaXNPYmplY3RMaWtlKHZhbHVlKSB8fFxuICAgICAgb2JqZWN0VG9TdHJpbmcuY2FsbCh2YWx1ZSkgIT0gb2JqZWN0VGFnIHx8IGlzSG9zdE9iamVjdCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIHByb3RvID0gZ2V0UHJvdG90eXBlKHZhbHVlKTtcbiAgaWYgKHByb3RvID09PSBudWxsKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgdmFyIEN0b3IgPSBoYXNPd25Qcm9wZXJ0eS5jYWxsKHByb3RvLCAnY29uc3RydWN0b3InKSAmJiBwcm90by5jb25zdHJ1Y3RvcjtcbiAgcmV0dXJuICh0eXBlb2YgQ3RvciA9PSAnZnVuY3Rpb24nICYmXG4gICAgQ3RvciBpbnN0YW5jZW9mIEN0b3IgJiYgZnVuY1RvU3RyaW5nLmNhbGwoQ3RvcikgPT0gb2JqZWN0Q3RvclN0cmluZyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNQbGFpbk9iamVjdDtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi4vfi9yZWR1eC9+L2xvZGFzaC9pc1BsYWluT2JqZWN0LmpzXG4gKiogbW9kdWxlIGlkID0gNFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xudmFyIG5hdGl2ZUdldFByb3RvdHlwZSA9IE9iamVjdC5nZXRQcm90b3R5cGVPZjtcblxuLyoqXG4gKiBHZXRzIHRoZSBgW1tQcm90b3R5cGVdXWAgb2YgYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7bnVsbHxPYmplY3R9IFJldHVybnMgdGhlIGBbW1Byb3RvdHlwZV1dYC5cbiAqL1xuZnVuY3Rpb24gZ2V0UHJvdG90eXBlKHZhbHVlKSB7XG4gIHJldHVybiBuYXRpdmVHZXRQcm90b3R5cGUoT2JqZWN0KHZhbHVlKSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0UHJvdG90eXBlO1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuLi9+L3JlZHV4L34vbG9kYXNoL19nZXRQcm90b3R5cGUuanNcbiAqKiBtb2R1bGUgaWQgPSA1XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgaG9zdCBvYmplY3QgaW4gSUUgPCA5LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgaG9zdCBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNIb3N0T2JqZWN0KHZhbHVlKSB7XG4gIC8vIE1hbnkgaG9zdCBvYmplY3RzIGFyZSBgT2JqZWN0YCBvYmplY3RzIHRoYXQgY2FuIGNvZXJjZSB0byBzdHJpbmdzXG4gIC8vIGRlc3BpdGUgaGF2aW5nIGltcHJvcGVybHkgZGVmaW5lZCBgdG9TdHJpbmdgIG1ldGhvZHMuXG4gIHZhciByZXN1bHQgPSBmYWxzZTtcbiAgaWYgKHZhbHVlICE9IG51bGwgJiYgdHlwZW9mIHZhbHVlLnRvU3RyaW5nICE9ICdmdW5jdGlvbicpIHtcbiAgICB0cnkge1xuICAgICAgcmVzdWx0ID0gISEodmFsdWUgKyAnJyk7XG4gICAgfSBjYXRjaCAoZSkge31cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzSG9zdE9iamVjdDtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi4vfi9yZWR1eC9+L2xvZGFzaC9faXNIb3N0T2JqZWN0LmpzXG4gKiogbW9kdWxlIGlkID0gNlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBvYmplY3QtbGlrZS4gQSB2YWx1ZSBpcyBvYmplY3QtbGlrZSBpZiBpdCdzIG5vdCBgbnVsbGBcbiAqIGFuZCBoYXMgYSBgdHlwZW9mYCByZXN1bHQgb2YgXCJvYmplY3RcIi5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBvYmplY3QtbGlrZSwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZSh7fSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdExpa2UoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShfLm5vb3ApO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShudWxsKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzT2JqZWN0TGlrZSh2YWx1ZSkge1xuICByZXR1cm4gISF2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT0gJ29iamVjdCc7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNPYmplY3RMaWtlO1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuLi9+L3JlZHV4L34vbG9kYXNoL2lzT2JqZWN0TGlrZS5qc1xuICoqIG1vZHVsZSBpZCA9IDdcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qIGdsb2JhbCB3aW5kb3cgKi9cbid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL3BvbnlmaWxsJykoZ2xvYmFsIHx8IHdpbmRvdyB8fCB0aGlzKTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi4vfi9zeW1ib2wtb2JzZXJ2YWJsZS9pbmRleC5qc1xuICoqIG1vZHVsZSBpZCA9IDhcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBzeW1ib2xPYnNlcnZhYmxlUG9ueWZpbGwocm9vdCkge1xuXHR2YXIgcmVzdWx0O1xuXHR2YXIgU3ltYm9sID0gcm9vdC5TeW1ib2w7XG5cblx0aWYgKHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicpIHtcblx0XHRpZiAoU3ltYm9sLm9ic2VydmFibGUpIHtcblx0XHRcdHJlc3VsdCA9IFN5bWJvbC5vYnNlcnZhYmxlO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXN1bHQgPSBTeW1ib2woJ29ic2VydmFibGUnKTtcblx0XHRcdFN5bWJvbC5vYnNlcnZhYmxlID0gcmVzdWx0O1xuXHRcdH1cblx0fSBlbHNlIHtcblx0XHRyZXN1bHQgPSAnQEBvYnNlcnZhYmxlJztcblx0fVxuXG5cdHJldHVybiByZXN1bHQ7XG59O1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuLi9+L3N5bWJvbC1vYnNlcnZhYmxlL3BvbnlmaWxsLmpzXG4gKiogbW9kdWxlIGlkID0gOVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBjb21iaW5lUmVkdWNlcnM7XG5cbnZhciBfY3JlYXRlU3RvcmUgPSByZXF1aXJlKCcuL2NyZWF0ZVN0b3JlJyk7XG5cbnZhciBfaXNQbGFpbk9iamVjdCA9IHJlcXVpcmUoJ2xvZGFzaC9pc1BsYWluT2JqZWN0Jyk7XG5cbnZhciBfaXNQbGFpbk9iamVjdDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9pc1BsYWluT2JqZWN0KTtcblxudmFyIF93YXJuaW5nID0gcmVxdWlyZSgnLi91dGlscy93YXJuaW5nJyk7XG5cbnZhciBfd2FybmluZzIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF93YXJuaW5nKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgXCJkZWZhdWx0XCI6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIGdldFVuZGVmaW5lZFN0YXRlRXJyb3JNZXNzYWdlKGtleSwgYWN0aW9uKSB7XG4gIHZhciBhY3Rpb25UeXBlID0gYWN0aW9uICYmIGFjdGlvbi50eXBlO1xuICB2YXIgYWN0aW9uTmFtZSA9IGFjdGlvblR5cGUgJiYgJ1wiJyArIGFjdGlvblR5cGUudG9TdHJpbmcoKSArICdcIicgfHwgJ2FuIGFjdGlvbic7XG5cbiAgcmV0dXJuICdHaXZlbiBhY3Rpb24gJyArIGFjdGlvbk5hbWUgKyAnLCByZWR1Y2VyIFwiJyArIGtleSArICdcIiByZXR1cm5lZCB1bmRlZmluZWQuICcgKyAnVG8gaWdub3JlIGFuIGFjdGlvbiwgeW91IG11c3QgZXhwbGljaXRseSByZXR1cm4gdGhlIHByZXZpb3VzIHN0YXRlLic7XG59XG5cbmZ1bmN0aW9uIGdldFVuZXhwZWN0ZWRTdGF0ZVNoYXBlV2FybmluZ01lc3NhZ2UoaW5wdXRTdGF0ZSwgcmVkdWNlcnMsIGFjdGlvbikge1xuICB2YXIgcmVkdWNlcktleXMgPSBPYmplY3Qua2V5cyhyZWR1Y2Vycyk7XG4gIHZhciBhcmd1bWVudE5hbWUgPSBhY3Rpb24gJiYgYWN0aW9uLnR5cGUgPT09IF9jcmVhdGVTdG9yZS5BY3Rpb25UeXBlcy5JTklUID8gJ2luaXRpYWxTdGF0ZSBhcmd1bWVudCBwYXNzZWQgdG8gY3JlYXRlU3RvcmUnIDogJ3ByZXZpb3VzIHN0YXRlIHJlY2VpdmVkIGJ5IHRoZSByZWR1Y2VyJztcblxuICBpZiAocmVkdWNlcktleXMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuICdTdG9yZSBkb2VzIG5vdCBoYXZlIGEgdmFsaWQgcmVkdWNlci4gTWFrZSBzdXJlIHRoZSBhcmd1bWVudCBwYXNzZWQgJyArICd0byBjb21iaW5lUmVkdWNlcnMgaXMgYW4gb2JqZWN0IHdob3NlIHZhbHVlcyBhcmUgcmVkdWNlcnMuJztcbiAgfVxuXG4gIGlmICghKDAsIF9pc1BsYWluT2JqZWN0MltcImRlZmF1bHRcIl0pKGlucHV0U3RhdGUpKSB7XG4gICAgcmV0dXJuICdUaGUgJyArIGFyZ3VtZW50TmFtZSArICcgaGFzIHVuZXhwZWN0ZWQgdHlwZSBvZiBcIicgKyB7fS50b1N0cmluZy5jYWxsKGlucHV0U3RhdGUpLm1hdGNoKC9cXHMoW2EtenxBLVpdKykvKVsxXSArICdcIi4gRXhwZWN0ZWQgYXJndW1lbnQgdG8gYmUgYW4gb2JqZWN0IHdpdGggdGhlIGZvbGxvd2luZyAnICsgKCdrZXlzOiBcIicgKyByZWR1Y2VyS2V5cy5qb2luKCdcIiwgXCInKSArICdcIicpO1xuICB9XG5cbiAgdmFyIHVuZXhwZWN0ZWRLZXlzID0gT2JqZWN0LmtleXMoaW5wdXRTdGF0ZSkuZmlsdGVyKGZ1bmN0aW9uIChrZXkpIHtcbiAgICByZXR1cm4gIXJlZHVjZXJzLmhhc093blByb3BlcnR5KGtleSk7XG4gIH0pO1xuXG4gIGlmICh1bmV4cGVjdGVkS2V5cy5sZW5ndGggPiAwKSB7XG4gICAgcmV0dXJuICdVbmV4cGVjdGVkICcgKyAodW5leHBlY3RlZEtleXMubGVuZ3RoID4gMSA/ICdrZXlzJyA6ICdrZXknKSArICcgJyArICgnXCInICsgdW5leHBlY3RlZEtleXMuam9pbignXCIsIFwiJykgKyAnXCIgZm91bmQgaW4gJyArIGFyZ3VtZW50TmFtZSArICcuICcpICsgJ0V4cGVjdGVkIHRvIGZpbmQgb25lIG9mIHRoZSBrbm93biByZWR1Y2VyIGtleXMgaW5zdGVhZDogJyArICgnXCInICsgcmVkdWNlcktleXMuam9pbignXCIsIFwiJykgKyAnXCIuIFVuZXhwZWN0ZWQga2V5cyB3aWxsIGJlIGlnbm9yZWQuJyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gYXNzZXJ0UmVkdWNlclNhbml0eShyZWR1Y2Vycykge1xuICBPYmplY3Qua2V5cyhyZWR1Y2VycykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgdmFyIHJlZHVjZXIgPSByZWR1Y2Vyc1trZXldO1xuICAgIHZhciBpbml0aWFsU3RhdGUgPSByZWR1Y2VyKHVuZGVmaW5lZCwgeyB0eXBlOiBfY3JlYXRlU3RvcmUuQWN0aW9uVHlwZXMuSU5JVCB9KTtcblxuICAgIGlmICh0eXBlb2YgaW5pdGlhbFN0YXRlID09PSAndW5kZWZpbmVkJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdSZWR1Y2VyIFwiJyArIGtleSArICdcIiByZXR1cm5lZCB1bmRlZmluZWQgZHVyaW5nIGluaXRpYWxpemF0aW9uLiAnICsgJ0lmIHRoZSBzdGF0ZSBwYXNzZWQgdG8gdGhlIHJlZHVjZXIgaXMgdW5kZWZpbmVkLCB5b3UgbXVzdCAnICsgJ2V4cGxpY2l0bHkgcmV0dXJuIHRoZSBpbml0aWFsIHN0YXRlLiBUaGUgaW5pdGlhbCBzdGF0ZSBtYXkgJyArICdub3QgYmUgdW5kZWZpbmVkLicpO1xuICAgIH1cblxuICAgIHZhciB0eXBlID0gJ0BAcmVkdXgvUFJPQkVfVU5LTk9XTl9BQ1RJT05fJyArIE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnN1YnN0cmluZyg3KS5zcGxpdCgnJykuam9pbignLicpO1xuICAgIGlmICh0eXBlb2YgcmVkdWNlcih1bmRlZmluZWQsIHsgdHlwZTogdHlwZSB9KSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignUmVkdWNlciBcIicgKyBrZXkgKyAnXCIgcmV0dXJuZWQgdW5kZWZpbmVkIHdoZW4gcHJvYmVkIHdpdGggYSByYW5kb20gdHlwZS4gJyArICgnRG9uXFwndCB0cnkgdG8gaGFuZGxlICcgKyBfY3JlYXRlU3RvcmUuQWN0aW9uVHlwZXMuSU5JVCArICcgb3Igb3RoZXIgYWN0aW9ucyBpbiBcInJlZHV4LypcIiAnKSArICduYW1lc3BhY2UuIFRoZXkgYXJlIGNvbnNpZGVyZWQgcHJpdmF0ZS4gSW5zdGVhZCwgeW91IG11c3QgcmV0dXJuIHRoZSAnICsgJ2N1cnJlbnQgc3RhdGUgZm9yIGFueSB1bmtub3duIGFjdGlvbnMsIHVubGVzcyBpdCBpcyB1bmRlZmluZWQsICcgKyAnaW4gd2hpY2ggY2FzZSB5b3UgbXVzdCByZXR1cm4gdGhlIGluaXRpYWwgc3RhdGUsIHJlZ2FyZGxlc3Mgb2YgdGhlICcgKyAnYWN0aW9uIHR5cGUuIFRoZSBpbml0aWFsIHN0YXRlIG1heSBub3QgYmUgdW5kZWZpbmVkLicpO1xuICAgIH1cbiAgfSk7XG59XG5cbi8qKlxuICogVHVybnMgYW4gb2JqZWN0IHdob3NlIHZhbHVlcyBhcmUgZGlmZmVyZW50IHJlZHVjZXIgZnVuY3Rpb25zLCBpbnRvIGEgc2luZ2xlXG4gKiByZWR1Y2VyIGZ1bmN0aW9uLiBJdCB3aWxsIGNhbGwgZXZlcnkgY2hpbGQgcmVkdWNlciwgYW5kIGdhdGhlciB0aGVpciByZXN1bHRzXG4gKiBpbnRvIGEgc2luZ2xlIHN0YXRlIG9iamVjdCwgd2hvc2Uga2V5cyBjb3JyZXNwb25kIHRvIHRoZSBrZXlzIG9mIHRoZSBwYXNzZWRcbiAqIHJlZHVjZXIgZnVuY3Rpb25zLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSByZWR1Y2VycyBBbiBvYmplY3Qgd2hvc2UgdmFsdWVzIGNvcnJlc3BvbmQgdG8gZGlmZmVyZW50XG4gKiByZWR1Y2VyIGZ1bmN0aW9ucyB0aGF0IG5lZWQgdG8gYmUgY29tYmluZWQgaW50byBvbmUuIE9uZSBoYW5keSB3YXkgdG8gb2J0YWluXG4gKiBpdCBpcyB0byB1c2UgRVM2IGBpbXBvcnQgKiBhcyByZWR1Y2Vyc2Agc3ludGF4LiBUaGUgcmVkdWNlcnMgbWF5IG5ldmVyIHJldHVyblxuICogdW5kZWZpbmVkIGZvciBhbnkgYWN0aW9uLiBJbnN0ZWFkLCB0aGV5IHNob3VsZCByZXR1cm4gdGhlaXIgaW5pdGlhbCBzdGF0ZVxuICogaWYgdGhlIHN0YXRlIHBhc3NlZCB0byB0aGVtIHdhcyB1bmRlZmluZWQsIGFuZCB0aGUgY3VycmVudCBzdGF0ZSBmb3IgYW55XG4gKiB1bnJlY29nbml6ZWQgYWN0aW9uLlxuICpcbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gQSByZWR1Y2VyIGZ1bmN0aW9uIHRoYXQgaW52b2tlcyBldmVyeSByZWR1Y2VyIGluc2lkZSB0aGVcbiAqIHBhc3NlZCBvYmplY3QsIGFuZCBidWlsZHMgYSBzdGF0ZSBvYmplY3Qgd2l0aCB0aGUgc2FtZSBzaGFwZS5cbiAqL1xuZnVuY3Rpb24gY29tYmluZVJlZHVjZXJzKHJlZHVjZXJzKSB7XG4gIHZhciByZWR1Y2VyS2V5cyA9IE9iamVjdC5rZXlzKHJlZHVjZXJzKTtcbiAgdmFyIGZpbmFsUmVkdWNlcnMgPSB7fTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCByZWR1Y2VyS2V5cy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBrZXkgPSByZWR1Y2VyS2V5c1tpXTtcbiAgICBpZiAodHlwZW9mIHJlZHVjZXJzW2tleV0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGZpbmFsUmVkdWNlcnNba2V5XSA9IHJlZHVjZXJzW2tleV07XG4gICAgfVxuICB9XG4gIHZhciBmaW5hbFJlZHVjZXJLZXlzID0gT2JqZWN0LmtleXMoZmluYWxSZWR1Y2Vycyk7XG5cbiAgdmFyIHNhbml0eUVycm9yO1xuICB0cnkge1xuICAgIGFzc2VydFJlZHVjZXJTYW5pdHkoZmluYWxSZWR1Y2Vycyk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBzYW5pdHlFcnJvciA9IGU7XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24gY29tYmluYXRpb24oKSB7XG4gICAgdmFyIHN0YXRlID0gYXJndW1lbnRzLmxlbmd0aCA8PSAwIHx8IGFyZ3VtZW50c1swXSA9PT0gdW5kZWZpbmVkID8ge30gOiBhcmd1bWVudHNbMF07XG4gICAgdmFyIGFjdGlvbiA9IGFyZ3VtZW50c1sxXTtcblxuICAgIGlmIChzYW5pdHlFcnJvcikge1xuICAgICAgdGhyb3cgc2FuaXR5RXJyb3I7XG4gICAgfVxuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHZhciB3YXJuaW5nTWVzc2FnZSA9IGdldFVuZXhwZWN0ZWRTdGF0ZVNoYXBlV2FybmluZ01lc3NhZ2Uoc3RhdGUsIGZpbmFsUmVkdWNlcnMsIGFjdGlvbik7XG4gICAgICBpZiAod2FybmluZ01lc3NhZ2UpIHtcbiAgICAgICAgKDAsIF93YXJuaW5nMltcImRlZmF1bHRcIl0pKHdhcm5pbmdNZXNzYWdlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgaGFzQ2hhbmdlZCA9IGZhbHNlO1xuICAgIHZhciBuZXh0U3RhdGUgPSB7fTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZpbmFsUmVkdWNlcktleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBrZXkgPSBmaW5hbFJlZHVjZXJLZXlzW2ldO1xuICAgICAgdmFyIHJlZHVjZXIgPSBmaW5hbFJlZHVjZXJzW2tleV07XG4gICAgICB2YXIgcHJldmlvdXNTdGF0ZUZvcktleSA9IHN0YXRlW2tleV07XG4gICAgICB2YXIgbmV4dFN0YXRlRm9yS2V5ID0gcmVkdWNlcihwcmV2aW91c1N0YXRlRm9yS2V5LCBhY3Rpb24pO1xuICAgICAgaWYgKHR5cGVvZiBuZXh0U3RhdGVGb3JLZXkgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHZhciBlcnJvck1lc3NhZ2UgPSBnZXRVbmRlZmluZWRTdGF0ZUVycm9yTWVzc2FnZShrZXksIGFjdGlvbik7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvck1lc3NhZ2UpO1xuICAgICAgfVxuICAgICAgbmV4dFN0YXRlW2tleV0gPSBuZXh0U3RhdGVGb3JLZXk7XG4gICAgICBoYXNDaGFuZ2VkID0gaGFzQ2hhbmdlZCB8fCBuZXh0U3RhdGVGb3JLZXkgIT09IHByZXZpb3VzU3RhdGVGb3JLZXk7XG4gICAgfVxuICAgIHJldHVybiBoYXNDaGFuZ2VkID8gbmV4dFN0YXRlIDogc3RhdGU7XG4gIH07XG59XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuLi9+L3JlZHV4L2xpYi9jb21iaW5lUmVkdWNlcnMuanNcbiAqKiBtb2R1bGUgaWQgPSAxMFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSB3YXJuaW5nO1xuLyoqXG4gKiBQcmludHMgYSB3YXJuaW5nIGluIHRoZSBjb25zb2xlIGlmIGl0IGV4aXN0cy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZSBUaGUgd2FybmluZyBtZXNzYWdlLlxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmZ1bmN0aW9uIHdhcm5pbmcobWVzc2FnZSkge1xuICAvKiBlc2xpbnQtZGlzYWJsZSBuby1jb25zb2xlICovXG4gIGlmICh0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIGNvbnNvbGUuZXJyb3IgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjb25zb2xlLmVycm9yKG1lc3NhZ2UpO1xuICB9XG4gIC8qIGVzbGludC1lbmFibGUgbm8tY29uc29sZSAqL1xuICB0cnkge1xuICAgIC8vIFRoaXMgZXJyb3Igd2FzIHRocm93biBhcyBhIGNvbnZlbmllbmNlIHNvIHRoYXQgaWYgeW91IGVuYWJsZVxuICAgIC8vIFwiYnJlYWsgb24gYWxsIGV4Y2VwdGlvbnNcIiBpbiB5b3VyIGNvbnNvbGUsXG4gICAgLy8gaXQgd291bGQgcGF1c2UgdGhlIGV4ZWN1dGlvbiBhdCB0aGlzIGxpbmUuXG4gICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xuICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLWVtcHR5ICovXG4gIH0gY2F0Y2ggKGUpIHt9XG4gIC8qIGVzbGludC1lbmFibGUgbm8tZW1wdHkgKi9cbn1cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4uL34vcmVkdXgvbGliL3V0aWxzL3dhcm5pbmcuanNcbiAqKiBtb2R1bGUgaWQgPSAxMVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBiaW5kQWN0aW9uQ3JlYXRvcnM7XG5mdW5jdGlvbiBiaW5kQWN0aW9uQ3JlYXRvcihhY3Rpb25DcmVhdG9yLCBkaXNwYXRjaCkge1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBkaXNwYXRjaChhY3Rpb25DcmVhdG9yLmFwcGx5KHVuZGVmaW5lZCwgYXJndW1lbnRzKSk7XG4gIH07XG59XG5cbi8qKlxuICogVHVybnMgYW4gb2JqZWN0IHdob3NlIHZhbHVlcyBhcmUgYWN0aW9uIGNyZWF0b3JzLCBpbnRvIGFuIG9iamVjdCB3aXRoIHRoZVxuICogc2FtZSBrZXlzLCBidXQgd2l0aCBldmVyeSBmdW5jdGlvbiB3cmFwcGVkIGludG8gYSBgZGlzcGF0Y2hgIGNhbGwgc28gdGhleVxuICogbWF5IGJlIGludm9rZWQgZGlyZWN0bHkuIFRoaXMgaXMganVzdCBhIGNvbnZlbmllbmNlIG1ldGhvZCwgYXMgeW91IGNhbiBjYWxsXG4gKiBgc3RvcmUuZGlzcGF0Y2goTXlBY3Rpb25DcmVhdG9ycy5kb1NvbWV0aGluZygpKWAgeW91cnNlbGYganVzdCBmaW5lLlxuICpcbiAqIEZvciBjb252ZW5pZW5jZSwgeW91IGNhbiBhbHNvIHBhc3MgYSBzaW5nbGUgZnVuY3Rpb24gYXMgdGhlIGZpcnN0IGFyZ3VtZW50LFxuICogYW5kIGdldCBhIGZ1bmN0aW9uIGluIHJldHVybi5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufE9iamVjdH0gYWN0aW9uQ3JlYXRvcnMgQW4gb2JqZWN0IHdob3NlIHZhbHVlcyBhcmUgYWN0aW9uXG4gKiBjcmVhdG9yIGZ1bmN0aW9ucy4gT25lIGhhbmR5IHdheSB0byBvYnRhaW4gaXQgaXMgdG8gdXNlIEVTNiBgaW1wb3J0ICogYXNgXG4gKiBzeW50YXguIFlvdSBtYXkgYWxzbyBwYXNzIGEgc2luZ2xlIGZ1bmN0aW9uLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGRpc3BhdGNoIFRoZSBgZGlzcGF0Y2hgIGZ1bmN0aW9uIGF2YWlsYWJsZSBvbiB5b3VyIFJlZHV4XG4gKiBzdG9yZS5cbiAqXG4gKiBAcmV0dXJucyB7RnVuY3Rpb258T2JqZWN0fSBUaGUgb2JqZWN0IG1pbWlja2luZyB0aGUgb3JpZ2luYWwgb2JqZWN0LCBidXQgd2l0aFxuICogZXZlcnkgYWN0aW9uIGNyZWF0b3Igd3JhcHBlZCBpbnRvIHRoZSBgZGlzcGF0Y2hgIGNhbGwuIElmIHlvdSBwYXNzZWQgYVxuICogZnVuY3Rpb24gYXMgYGFjdGlvbkNyZWF0b3JzYCwgdGhlIHJldHVybiB2YWx1ZSB3aWxsIGFsc28gYmUgYSBzaW5nbGVcbiAqIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBiaW5kQWN0aW9uQ3JlYXRvcnMoYWN0aW9uQ3JlYXRvcnMsIGRpc3BhdGNoKSB7XG4gIGlmICh0eXBlb2YgYWN0aW9uQ3JlYXRvcnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gYmluZEFjdGlvbkNyZWF0b3IoYWN0aW9uQ3JlYXRvcnMsIGRpc3BhdGNoKTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgYWN0aW9uQ3JlYXRvcnMgIT09ICdvYmplY3QnIHx8IGFjdGlvbkNyZWF0b3JzID09PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdiaW5kQWN0aW9uQ3JlYXRvcnMgZXhwZWN0ZWQgYW4gb2JqZWN0IG9yIGEgZnVuY3Rpb24sIGluc3RlYWQgcmVjZWl2ZWQgJyArIChhY3Rpb25DcmVhdG9ycyA9PT0gbnVsbCA/ICdudWxsJyA6IHR5cGVvZiBhY3Rpb25DcmVhdG9ycykgKyAnLiAnICsgJ0RpZCB5b3Ugd3JpdGUgXCJpbXBvcnQgQWN0aW9uQ3JlYXRvcnMgZnJvbVwiIGluc3RlYWQgb2YgXCJpbXBvcnQgKiBhcyBBY3Rpb25DcmVhdG9ycyBmcm9tXCI/Jyk7XG4gIH1cblxuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGFjdGlvbkNyZWF0b3JzKTtcbiAgdmFyIGJvdW5kQWN0aW9uQ3JlYXRvcnMgPSB7fTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgdmFyIGFjdGlvbkNyZWF0b3IgPSBhY3Rpb25DcmVhdG9yc1trZXldO1xuICAgIGlmICh0eXBlb2YgYWN0aW9uQ3JlYXRvciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgYm91bmRBY3Rpb25DcmVhdG9yc1trZXldID0gYmluZEFjdGlvbkNyZWF0b3IoYWN0aW9uQ3JlYXRvciwgZGlzcGF0Y2gpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gYm91bmRBY3Rpb25DcmVhdG9ycztcbn1cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4uL34vcmVkdXgvbGliL2JpbmRBY3Rpb25DcmVhdG9ycy5qc1xuICoqIG1vZHVsZSBpZCA9IDEyXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07XG5cbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gYXBwbHlNaWRkbGV3YXJlO1xuXG52YXIgX2NvbXBvc2UgPSByZXF1aXJlKCcuL2NvbXBvc2UnKTtcblxudmFyIF9jb21wb3NlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NvbXBvc2UpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBcImRlZmF1bHRcIjogb2JqIH07IH1cblxuLyoqXG4gKiBDcmVhdGVzIGEgc3RvcmUgZW5oYW5jZXIgdGhhdCBhcHBsaWVzIG1pZGRsZXdhcmUgdG8gdGhlIGRpc3BhdGNoIG1ldGhvZFxuICogb2YgdGhlIFJlZHV4IHN0b3JlLiBUaGlzIGlzIGhhbmR5IGZvciBhIHZhcmlldHkgb2YgdGFza3MsIHN1Y2ggYXMgZXhwcmVzc2luZ1xuICogYXN5bmNocm9ub3VzIGFjdGlvbnMgaW4gYSBjb25jaXNlIG1hbm5lciwgb3IgbG9nZ2luZyBldmVyeSBhY3Rpb24gcGF5bG9hZC5cbiAqXG4gKiBTZWUgYHJlZHV4LXRodW5rYCBwYWNrYWdlIGFzIGFuIGV4YW1wbGUgb2YgdGhlIFJlZHV4IG1pZGRsZXdhcmUuXG4gKlxuICogQmVjYXVzZSBtaWRkbGV3YXJlIGlzIHBvdGVudGlhbGx5IGFzeW5jaHJvbm91cywgdGhpcyBzaG91bGQgYmUgdGhlIGZpcnN0XG4gKiBzdG9yZSBlbmhhbmNlciBpbiB0aGUgY29tcG9zaXRpb24gY2hhaW4uXG4gKlxuICogTm90ZSB0aGF0IGVhY2ggbWlkZGxld2FyZSB3aWxsIGJlIGdpdmVuIHRoZSBgZGlzcGF0Y2hgIGFuZCBgZ2V0U3RhdGVgIGZ1bmN0aW9uc1xuICogYXMgbmFtZWQgYXJndW1lbnRzLlxuICpcbiAqIEBwYXJhbSB7Li4uRnVuY3Rpb259IG1pZGRsZXdhcmVzIFRoZSBtaWRkbGV3YXJlIGNoYWluIHRvIGJlIGFwcGxpZWQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IEEgc3RvcmUgZW5oYW5jZXIgYXBwbHlpbmcgdGhlIG1pZGRsZXdhcmUuXG4gKi9cbmZ1bmN0aW9uIGFwcGx5TWlkZGxld2FyZSgpIHtcbiAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIG1pZGRsZXdhcmVzID0gQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgbWlkZGxld2FyZXNbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24gKGNyZWF0ZVN0b3JlKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChyZWR1Y2VyLCBpbml0aWFsU3RhdGUsIGVuaGFuY2VyKSB7XG4gICAgICB2YXIgc3RvcmUgPSBjcmVhdGVTdG9yZShyZWR1Y2VyLCBpbml0aWFsU3RhdGUsIGVuaGFuY2VyKTtcbiAgICAgIHZhciBfZGlzcGF0Y2ggPSBzdG9yZS5kaXNwYXRjaDtcbiAgICAgIHZhciBjaGFpbiA9IFtdO1xuXG4gICAgICB2YXIgbWlkZGxld2FyZUFQSSA9IHtcbiAgICAgICAgZ2V0U3RhdGU6IHN0b3JlLmdldFN0YXRlLFxuICAgICAgICBkaXNwYXRjaDogZnVuY3Rpb24gZGlzcGF0Y2goYWN0aW9uKSB7XG4gICAgICAgICAgcmV0dXJuIF9kaXNwYXRjaChhY3Rpb24pO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgY2hhaW4gPSBtaWRkbGV3YXJlcy5tYXAoZnVuY3Rpb24gKG1pZGRsZXdhcmUpIHtcbiAgICAgICAgcmV0dXJuIG1pZGRsZXdhcmUobWlkZGxld2FyZUFQSSk7XG4gICAgICB9KTtcbiAgICAgIF9kaXNwYXRjaCA9IF9jb21wb3NlMltcImRlZmF1bHRcIl0uYXBwbHkodW5kZWZpbmVkLCBjaGFpbikoc3RvcmUuZGlzcGF0Y2gpO1xuXG4gICAgICByZXR1cm4gX2V4dGVuZHMoe30sIHN0b3JlLCB7XG4gICAgICAgIGRpc3BhdGNoOiBfZGlzcGF0Y2hcbiAgICAgIH0pO1xuICAgIH07XG4gIH07XG59XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuLi9+L3JlZHV4L2xpYi9hcHBseU1pZGRsZXdhcmUuanNcbiAqKiBtb2R1bGUgaWQgPSAxM1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IGNvbXBvc2U7XG4vKipcbiAqIENvbXBvc2VzIHNpbmdsZS1hcmd1bWVudCBmdW5jdGlvbnMgZnJvbSByaWdodCB0byBsZWZ0LiBUaGUgcmlnaHRtb3N0XG4gKiBmdW5jdGlvbiBjYW4gdGFrZSBtdWx0aXBsZSBhcmd1bWVudHMgYXMgaXQgcHJvdmlkZXMgdGhlIHNpZ25hdHVyZSBmb3JcbiAqIHRoZSByZXN1bHRpbmcgY29tcG9zaXRlIGZ1bmN0aW9uLlxuICpcbiAqIEBwYXJhbSB7Li4uRnVuY3Rpb259IGZ1bmNzIFRoZSBmdW5jdGlvbnMgdG8gY29tcG9zZS5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gQSBmdW5jdGlvbiBvYnRhaW5lZCBieSBjb21wb3NpbmcgdGhlIGFyZ3VtZW50IGZ1bmN0aW9uc1xuICogZnJvbSByaWdodCB0byBsZWZ0LiBGb3IgZXhhbXBsZSwgY29tcG9zZShmLCBnLCBoKSBpcyBpZGVudGljYWwgdG8gZG9pbmdcbiAqICguLi5hcmdzKSA9PiBmKGcoaCguLi5hcmdzKSkpLlxuICovXG5cbmZ1bmN0aW9uIGNvbXBvc2UoKSB7XG4gIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBmdW5jcyA9IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgIGZ1bmNzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICB9XG5cbiAgaWYgKGZ1bmNzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoYXJnKSB7XG4gICAgICByZXR1cm4gYXJnO1xuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgdmFyIF9yZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgbGFzdCA9IGZ1bmNzW2Z1bmNzLmxlbmd0aCAtIDFdO1xuICAgICAgdmFyIHJlc3QgPSBmdW5jcy5zbGljZSgwLCAtMSk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB2OiBmdW5jdGlvbiB2KCkge1xuICAgICAgICAgIHJldHVybiByZXN0LnJlZHVjZVJpZ2h0KGZ1bmN0aW9uIChjb21wb3NlZCwgZikge1xuICAgICAgICAgICAgcmV0dXJuIGYoY29tcG9zZWQpO1xuICAgICAgICAgIH0sIGxhc3QuYXBwbHkodW5kZWZpbmVkLCBhcmd1bWVudHMpKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9KCk7XG5cbiAgICBpZiAodHlwZW9mIF9yZXQgPT09IFwib2JqZWN0XCIpIHJldHVybiBfcmV0LnY7XG4gIH1cbn1cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4uL34vcmVkdXgvbGliL2NvbXBvc2UuanNcbiAqKiBtb2R1bGUgaWQgPSAxNFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gc3JjIChmb3IgbW9zdCk6IGh0dHBzOi8vZmxhdHVpY29sb3JzLmNvbS9cbmNvbnN0IFJFRCA9ICcjRTc0QzNDJyxcbiAgICBPUkFOR0UgPSAnI0U2N0UyMicsXG4gICAgUFVSUExFID0gJyM5QjU5QjYnLFxuICAgIEJMVUUgPSAnIzI5ODBCOScsXG4gICAgUElOSyA9ICcjRTkxRTYzJyxcbiAgICBZRUxMT1cgPSAnI0YxQzQwRicsXG4gICAgR09MRCA9ICcjRjM5QzEyJyxcbiAgICBHUkVFTiA9ICcjMkVDQzcxJyxcbiAgICBHUkVZID0gJyM3RjhDOEQnLFxuICAgIFNJTFZFUiA9ICcjQkRDM0M3JyxcbiAgICBXSElURSA9ICcjRUNGMEYxJyxcbiAgICBCTEFDSyA9ICcjMDAwMDAwJyxcbiAgICBCUk9XTiA9ICcjNzk1NTQ4JztcblxuLy8gaW5mb2dyYXBoaWMgaW5zcGlyYXRpb246XG4vLyBodHRwOi8vd3d3LmluZm9ybWF0aW9uaXNiZWF1dGlmdWwubmV0L3Zpc3VhbGl6YXRpb25zL2NvbG91cnMtaW4tY3VsdHVyZXMvXG5cbmNvbnN0IHdlc3Rlcm4gPSB7XG4gICAgJ0FuZ2VyJzogUkVELFxuICAgICdBdXRob3JpdHknOiBCTEFDSyxcbiAgICAnQmVhdXR5JzogUFVSUExFLFxuICAgICdDaGlsZHJlbic6IFBJTkssXG4gICAgJ0NvbGQnOiBCTFVFLFxuICAgICdDb3VyYWdlJzogT1JBTkdFLFxuICAgICdDb3dhcmRpY2UnOiBZRUxMT1csXG4gICAgJ0NydWVsdHknOiBQVVJQTEUsXG4gICAgJ0Rhbmdlcic6IFJFRCxcbiAgICAnRGVhdGgnOiBCTEFDSyxcbiAgICAnRGVjYWRlbmNlJzogUFVSUExFLFxuICAgICdEZXNpcmUnOiBSRUQsXG4gICAgJ0VhcnRoeSc6IEJST1dOLFxuICAgICdFbmVyZ3knOiBZRUxMT1csXG4gICAgJ0Vyb3RpYyc6IE9SQU5HRSxcbiAgICAnRmVtaW5pbml0eSc6IFBJTkssXG4gICAgJ0ZsYW1ib3lhbmNlJzogUFVSUExFLFxuICAgICdGcmVlZG9tJzogQkxVRSxcbiAgICAnRnJpZW5kbHknOiBPUkFOR0UsXG4gICAgJ0Z1bic6IFlFTExPVyxcbiAgICAnR29vZCBMdWNrJzogR1JFRU4sXG4gICAgJ0dyb3d0aCc6IEdSRUVOLFxuICAgICdIYXBwaW5lc3MnOiBZRUxMT1csXG4gICAgJ0hlYWxpbmcnOiBCTFVFLFxuICAgICdIZWF0JzogUkVELFxuICAgICdIZWF2ZW4nOiBXSElURSxcbiAgICAnSW50ZWxsaWdlbmNlJzogQkxVRSxcbiAgICAnSmVhbG91c3knOiBHUkVFTixcbiAgICAnTG92ZSc6IFJFRCxcbiAgICAnTG95YWx0eSc6IEJMVUUsXG4gICAgJ0x1eHVyeSc6IFdISVRFLFxuICAgICdNYXJyaWFnZSc6IFdISVRFLFxuICAgICdNb2Rlc3R5JzogUFVSUExFLFxuICAgICdNb25leSc6IEdPTEQsXG4gICAgJ01vdXJuaW5nJzogQkxBQ0ssXG4gICAgJ015c3RlcnknOiBQVVJQTEUsXG4gICAgJ05hdHVyZSc6IEdSRUVOLFxuICAgICdQYXNzaW9uJzogUkVELFxuICAgICdQZWFjZSc6IFlFTExPVyxcbiAgICAnUGVyc29uYWwgUG93ZXInOiBQVVJQTEUsXG4gICAgJ1B1cml0eSc6IFdISVRFLFxuICAgICdSYWRpY2FsaXNtJzogUkVELFxuICAgICdSYXRpb25hbCc6IEJMVUUsXG4gICAgJ1JlbGlhYmxlJzogQlJPV04sXG4gICAgJ1JlcGVscyBFdmlsJzogWUVMTE9XLFxuICAgICdSZXNwZWN0JzogR1JFWSxcbiAgICAnU3R5bGUnOiBCTEFDSyxcbiAgICAnVHJ1Y2UnOiBXSElURSxcbiAgICAnVW5oYXBwaW5lc3MnOiBCTFVFLFxuICAgICdWaXJ0dWUnOiBQVVJQTEVcbn07XG5cbmNvbnN0IGphcGFuZXNlID0ge1xuICAgICdBcnQvQ3JlYXRpdml0eSc6IFJFRCxcbiAgICAnQmFkIEx1Y2snOiBCTEFDSyxcbiAgICAnQmFsYW5jZSc6IE9SQU5HRSxcbiAgICAnQ2VsZWJyYXRpb24nOiBQVVJQTEUsXG4gICAgJ0NoaWxkcmVuJzogUElOSyxcbiAgICAnQ29sZCc6IEJMVUUsXG4gICAgJ0NvdXJhZ2UnOiBZRUxMT1csXG4gICAgJ0Nvd2FyZGljZSc6IFlFTExPVyxcbiAgICAnRGFuZ2VyJzogUkVELFxuICAgICdEZWF0aCc6IEJMQUNLLFxuICAgICdEZWNhZGVuY2UnOiBQVVJQTEUsXG4gICAgJ0RlY2VpdCc6IFlFTExPVyxcbiAgICAnRGVzaXJlJzogUkVELFxuICAgICdFbmVyZ3knOiBPUkFOR0UsXG4gICAgJ0Vyb3RpYyc6IFBJTkssXG4gICAgJ0V0ZXJuaXR5JzogR1JFRU4sXG4gICAgJ0V2aWwnOiBCTEFDSyxcbiAgICAnRXhjaXRlbWVudCc6IFJFRCxcbiAgICAnRmxhbWJveWFuY2UnOiBPUkFOR0UsXG4gICAgJ0dvZCc6IFBVUlBMRSxcbiAgICAnR29vZCBMdWNrJzogR1JFRU4sXG4gICAgJ0hlYWx0aHknOiBQSU5LLFxuICAgICdIZWF2ZW4nOiBZRUxMT1csXG4gICAgJ0hvbGluZXNzJzogV0hJVEUsXG4gICAgJ0lsbmVzcyc6IFlFTExPVyxcbiAgICAnSW5zaWdodCc6IFBVUlBMRSxcbiAgICAnSW50ZWxsaWdlbmNlJzogU0lMVkVSLFxuICAgICdSZWxpZ2lvbic6IFlFTExPVyxcbiAgICAnSmVhbG91c3knOiBHUkVFTixcbiAgICAnSm95JzogWUVMTE9XLFxuICAgICdMaWZlJzogQkxVRSxcbiAgICAnTG92ZSc6IFJFRCxcbiAgICAnTG95YWx0eSc6IEJMVUUsXG4gICAgJ01vZGVzdHknOiBHUkVZLFxuICAgICdNb25leSc6IEJMVUUsXG4gICAgJ015c3RlcnknOiBQVVJQTEUsXG4gICAgJ05hdHVyZSc6IEdSRUVOLFxuICAgICdQYXNzaW9uJzogUkVELFxuICAgICdQZWFjZSc6IEJMVUUsXG4gICAgJ1B1cml0eSc6IFdISVRFLFxuICAgICdSYXRpb25hbCc6IEJMVUUsXG4gICAgJ1JlbGlhYmxlJzogR1JFWSxcbiAgICAnUmVwZWxzIEV2aWwnOiBSRUQsXG4gICAgJ1Jlc3BlY3QnOiBXSElURSxcbiAgICAnU3RyZW5ndGgnOiBSRUQsXG4gICAgJ1N0eWxlJzogQkxBQ0ssXG4gICAgJ1RydWNlJzogV0hJVEUsXG4gICAgJ1VuaGFwcGluZXNzJzogQkxBQ0ssXG4gICAgJ1dhcm10aCc6IE9SQU5HRSxcbiAgICAnV2lzZG9tJzogUFVSUExFXG59O1xuXG5jb25zdCBoaW5kdSA9IHtcbiAgICAnQW5nZXInOiBCTEFDSyxcbiAgICAnQXJ0L0NyZWF0aXZpdHknOiBCTFVFLFxuICAgICdDb21wYXNzaW9uJzogR1JFRU4sXG4gICAgJ0NvdXJhZ2UnOiBPUkFOR0UsXG4gICAgJ0RlYXRoJzogV0hJVEUsXG4gICAgJ0Rlc2lyZSc6IE9SQU5HRSxcbiAgICAnRW5lcmd5JzogUkVELFxuICAgICdFcm90aWMnOiBSRUQsXG4gICAgJ0V2aWwnOiBCTEFDSyxcbiAgICAnRnVuJzogWUVMTE9XLFxuICAgICdHb2QnOiBZRUxMT1csXG4gICAgJ0dvZHMnOiBCTFVFLFxuICAgICdIYXBwaW5lc3MnOiBHUkVFTixcbiAgICAnSGVhdCc6IFJFRCxcbiAgICAnSWxsbmVzcyc6IFlFTExPVyxcbiAgICAnSW5zaWdodCc6IEdSRUVOLFxuICAgICdJbnRlbGxpZ2VuY2UnOiBXSElURSxcbiAgICAnSW50dWl0aW9uJzogUFVSUExFLFxuICAgICdSZWxpZ2lvbic6IEdSRUVOLFxuICAgICdKb3knOiBZRUxMT1csXG4gICAgJ0xpZmUnOiBHUkVFTixcbiAgICAnTG92ZSc6IEdSRUVOLFxuICAgICdNYXJyaWFnZSc6IFJFRCxcbiAgICAnUGFzc2lvbic6IFJFRCxcbiAgICAnUGVhY2UnOiBXSElURSxcbiAgICAnUGVuYW5jZSc6IEJMQUNLLFxuICAgICdQZXJzb25hbCBQb3dlcic6IFlFTExPVyxcbiAgICAnUmVwZWxzIEV2aWwnOiBZRUxMT1csXG4gICAgJ1RydWNlJzogV0hJVEUsXG4gICAgJ1dpc2RvbSc6IFBVUlBMRVxufTtcblxuY29uc3QgbmF0aXZlX2FtZXJpY2FuID0ge1xuICAgICdCYWxhbmNlJzogQkxBQ0ssXG4gICAgJ0NvbGQnOiBCTFVFLFxuICAgICdEYW5nZXInOiBZRUxMT1csXG4gICAgJ0RlYXRoJzogQkxBQ0ssXG4gICAgJ0ZyaWVuZGx5JzogR1JFWSxcbiAgICAnR3JhdGl0dWRlJzogUFVSUExFLFxuICAgICdIYXBwaW5lc3MnOiBXSElURSxcbiAgICAnSGVhbGluZyc6IE9SQU5HRSxcbiAgICAnSW5zaWdodCc6IFlFTExPVyxcbiAgICAnSW50dWl0aW9uJzogQkxVRSxcbiAgICAnTGVhcm5pbmcnOiBPUkFOR0UsXG4gICAgJ0xvdmUnOiBZRUxMT1csXG4gICAgJ1Bhc3Npb24nOiBSRUQsXG4gICAgJ1BlYWNlJzogV0hJVEUsXG4gICAgJ1BlcnNvbmFsIFBvd2VyJzogR1JFRU4sXG4gICAgJ1Jlc3BlY3QnOiBTSUxWRVIsXG4gICAgJ1NlbGYtQ3VsdGl2YXRpb24nOiBCTEFDSyxcbiAgICAnU3VjY2Vzcyc6IFJFRCxcbiAgICAnVHJvdWJsZSc6IEJMVUUsXG4gICAgJ1VuaGFwcGluZXNzJzogQkxVRSxcbiAgICAnV2lzZG9tJzogQlJPV05cbn07XG5cbmNvbnN0IGNoaW5lc2UgPSB7XG4gICAgJ0NlbGVicmF0aW9uJzogQkxBQ0ssXG4gICAgJ0RlYXRoJzogV0hJVEUsXG4gICAgJ0VhcnRoeSc6IEJST1dOLFxuICAgICdGYW1pbHknOiBPUkFOR0UsXG4gICAgJ0ZlcnRpbGl0eSc6IFJFRCxcbiAgICAnR29vZCBMdWNrJzogUkVELFxuICAgICdHcm93dGgnOiBHUkVFTixcbiAgICAnSGFwcGluZXNzJzogUkVELFxuICAgICdIZWFsdGh5JzogWUVMTE9XLFxuICAgICdMZWFybmluZyc6IE9SQU5HRSxcbiAgICAnTGlmZSc6IEdSRUVOLFxuICAgICdNYXJyaWFnZSc6IFJFRCxcbiAgICAnTW91cm5pbmcnOiBXSElURSxcbiAgICAnUmVwZWxzIEV2aWwnOiBHUkVFTixcbiAgICAnUmVzcGVjdCc6IFlFTExPVyxcbiAgICAnUm95YWx0eSc6IFlFTExPVyxcbiAgICAnU3VjY2Vzcyc6IFJFRCxcbiAgICAnTW9uZXknOiBHT0xELFxuICAgICdQdXJpdHknOiBXSElURSxcbiAgICAnVHJ1Y2UnOiBXSElURSxcbn07XG5cbmNvbnN0IGFzaWFuID0ge1xuICAgICdCYWxhbmNlJzogR1JFRU4sXG4gICAgJ0NoaWxkcmVuJzogV0hJVEUsXG4gICAgJ0V0ZXJuaXR5JzogR1JFRU4sXG4gICAgJ0V2aWwnOiBCTEFDSyxcbiAgICAnRXhjaXRlbWVudCc6IEdSRUVOLFxuICAgICdGbGFtYm95YW5jZSc6IFBVUlBMRSxcbiAgICAnSGFwcGluZXNzJzogUkVELFxuICAgICdIb2xpbmVzcyc6IFlFTExPVyxcbiAgICAnSW50ZWxsaWdlbmNlJzogQkxBQ0ssXG4gICAgJ01vbmV5JzogR09MRCxcbiAgICAnUGVuYW5jZSc6IEJMQUNLLFxuICAgICdQb3dlcic6IFlFTExPVyxcbiAgICAnUHVyaXR5JzogV0hJVEUsXG4gICAgJ1JlcGVscyBFdmlsJzogWUVMTE9XLFxuICAgICdTZWxmIEN1bHRpdmF0aW9uJzogQkxBQ0ssXG4gICAgJ1N0cmVuZ3RoJzogWUVMTE9XLFxuICAgICdTdWNjZXNzJzogUkVEXG59O1xuXG5jb25zdCBlYXN0ZXJuX2V1cm9wZWFuID0ge1xuICAgICdBbmdlcic6IFJFRCxcbiAgICAnSGVhdCc6IFJFRCxcbiAgICAnQmVhdXR5JzogUkVELFxuICAgICdHb29kIEx1Y2snOiBSRUQsXG4gICAgJ0hlYXQnOiBSRUQsXG4gICAgJ0xvdmUnOiBSRUQsXG4gICAgJ0xveWFsdHknOiBCTFVFLFxuICAgICdNb3VybmluZyc6IFlFTExPVyxcbiAgICAnUGFzc2lvbic6IFJFRCxcbiAgICAnUG93ZXInOiBSRUQsXG4gICAgJ1JhZGljYWxpc20nOiBSRUQsXG4gICAgJ1RydWNlJzogV0hJVEUsXG4gICAgJ1RydXN0JzogV0hJVEUsXG4gICAgJ1ZpcnR1ZSc6IEJMVUUsXG4gICAgJ1dpc2RvbSc6IEJMVUVcbn07XG5cbmNvbnN0IG11c2xpbSA9IHtcbiAgICAnRGVhdGgnOiBTSUxWRVIsXG4gICAgJ0dvZCc6IEdSRUVOLFxuICAgICdHb29kIEx1Y2snOiBHUkVFTixcbiAgICAnSGVhdCc6IFJFRCxcbiAgICAnSGVhdmVuJzogR1JFRU4sXG4gICAgJ1JlbGlnaW9uJzogR1JFRU4sXG4gICAgJ1BlYWNlJzogU0lMVkVSLFxuICAgICdQdXJpdHknOiBTSUxWRVIsXG4gICAgJ1N0cmVuZ3RoJzogWUVMTE9XLFxuICAgICdUcnVjZSc6IFNJTFZFUlxufTtcblxuY29uc3QgYWZyaWNhbiA9IHtcbiAgICAnQW5nZXInOiBSRUQsXG4gICAgJ0dvb2QgTHVjayc6IFJFRCxcbiAgICAnUmVsaWdpb24nOiBHUkVFTixcbiAgICAnTGVhcm5pbmcnOiBHUkVFTixcbiAgICAnTGlmZSc6IEJMVUUsXG4gICAgJ1BlYWNlJzogQkxVRSxcbiAgICAnU3VjY2Vzcyc6IEdSRUVOLFxuICAgICdUcnVjZSc6IEdSRVlcbn07XG5cbmNvbnN0IHNvdXRoX2FtZXJpY2FuID0ge1xuICAgICdEYW5nZXInOiBSRUQsXG4gICAgJ0RlYXRoJzogR1JFRU4sXG4gICAgJ01vdXJuaW5nJzogUFVSUExFLFxuICAgICdTdWNjZXNzJzogUkVELFxuICAgICdUcm91YmxlJzogQkxVRVxufTtcblxuLy8gU3RyaW5nLT5PYmplY3QgbG9va3VwIHRhYmxlXG5jb25zdCBjdWx0dXJlcyA9IHtcbiAgJ1dlc3Rlcm4nOiB3ZXN0ZXJuLFxuICAnSmFwYW5lc2UnOiBqYXBhbmVzZSxcbiAgJ0hpbmR1JzogaGluZHUsXG4gICdOYXRpdmUgQW1lcmljYW4nOiBuYXRpdmVfYW1lcmljYW4sXG4gICdDaGluZXNlJzogY2hpbmVzZSxcbiAgJ0FzaWFuJzogYXNpYW4sXG4gICdFYXN0ZXJuIEV1cm9wZWFuJzogZWFzdGVybl9ldXJvcGVhbixcbiAgJ011c2xpbSc6IG11c2xpbSxcbiAgJ0FmcmljYW4nOiBhZnJpY2FuLFxuICAnU291dGggQW1lcmljYW4nOiBzb3V0aF9hbWVyaWNhblxufTtcblxuLy8gYWxwaGFiZXRpemVkIGFycmF5IG9mIGN1bHR1cmVzXG5jb25zdCBjdWx0dXJlc19saXN0ID0gW1wiQWZyaWNhblwiLCBcIkFzaWFuXCIsIFwiQ2hpbmVzZVwiLCBcIkVhc3Rlcm4gRXVyb3BlYW5cIiwgXCJIaW5kdVwiLCBcIkphcGFuZXNlXCIsIFwiTXVzbGltXCIsIFwiTmF0aXZlIEFtZXJpY2FuXCIsIFwiU291dGggQW1lcmljYW5cIiwgXCJXZXN0ZXJuXCJdO1xuXG5cbmV4cG9ydHMuY3VsdHVyZXMgPSBjdWx0dXJlcztcbmV4cG9ydHMuY3VsdHVyZXNfbGlzdCA9IGN1bHR1cmVzX2xpc3Q7XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL2N1bHR1cmVfZGF0YS5qc1xuICoqLyIsIi8vIDEuIEdvb2dsZSBBbmFseXRpY3Ncbi8vIDIuIHJvdGF0ZXMgdGhyb3VnaG91dCB0aGUgZmxhdCBVSSBjb2xvcnMgZm9yIHRoZSBoZWFydCBhdCB0aGUgYm9yZGVyLWJvdHRvbS5cbi8vIDMuIDNyZC1wYXJ0eSBsaWJyYXJ5IGZvciBpbmxpbmUtdHdlZXRzIHNoYXJpbmcgZnVuY3Rpb25hbGl0eS5cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbigpIHtcbiAgICAndXNlIHN0cmljdCc7XG4gICAgKGZ1bmN0aW9uKGkscyxvLGcscixhLG0pe2lbJ0dvb2dsZUFuYWx5dGljc09iamVjdCddPXI7aVtyXT1pW3JdfHxmdW5jdGlvbigpe1xuICAgICAgKGlbcl0ucT1pW3JdLnF8fFtdKS5wdXNoKGFyZ3VtZW50cyl9LGlbcl0ubD0xKm5ldyBEYXRlKCk7YT1zLmNyZWF0ZUVsZW1lbnQobyksXG4gICAgICBtPXMuZ2V0RWxlbWVudHNCeVRhZ05hbWUobylbMF07YS5hc3luYz0xO2Euc3JjPWc7bS5wYXJlbnROb2RlLmluc2VydEJlZm9yZShhLG0pXG4gICAgfSkod2luZG93LGRvY3VtZW50LCdzY3JpcHQnLCdodHRwczovL3d3dy5nb29nbGUtYW5hbHl0aWNzLmNvbS9hbmFseXRpY3MuanMnLCdnYScpO1xuICAgIGdhKCdjcmVhdGUnLCAnVUEtNzY1NTUwMDAtMScsICdhdXRvJyk7XG4gICAgZ2EoJ3NlbmQnLCAncGFnZXZpZXcnKTtcbiAgICAvLyBsb29wcyB0aHJvdWdoIGhlYXJ0IGljb24gKGZvb3RlcikgY29sb3JzXG4gICAgdmFyICRoZWFydCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCcjaGVhcnQnKTtcbiAgICB2YXIgZmxhdFVJQ29sb3JzID0gWycjMzQ0OTVlJywgJyM1OTAwZmYnLCAnIzliNTliNicsICcjMzQ5OGRiJywgJyMyZWNjNzEnLCAnIzFhYmM5YycsICcjZjFjNDBmJywgJyNlY2YwZjEnLCAnI2U2N2UyMicsICcjZTc0YzNjJywgJyM5NWE1YTYnXTtcbiAgICB2YXIgY291bnRlciA9IDA7XG4gICAgdmFyIHVwZGF0ZUludGVydmFsID0gMTAwMDtcbiAgICBzZXRJbnRlcnZhbChmdW5jdGlvbiBjaGFuZ2VIZWFydENvbG9yKCkge1xuICAgICAgICBpZiAoIWZsYXRVSUNvbG9yc1tjb3VudGVyXSkgY291bnRlciA9IDBcbiAgICAgICAgaGVhcnQuc3R5bGUuY29sb3IgPSBmbGF0VUlDb2xvcnNbY291bnRlcisrXVxuICAgIH0sIHVwZGF0ZUludGVydmFsKTtcbiAgICAvLyBpbmxpbmVUd2VldC5qc1xuICAgIGZ1bmN0aW9uIGJ1aWxkSW5saW5lVHdlZXQoZSkge1xuICAgICAgICB2YXIgdCA9IGUuaW5uZXJIVE1MLFxuICAgICAgICAgICAgaSA9IFwiJTIyXCIgKyBlbmNvZGVVUklDb21wb25lbnQodCkgKyBcIiUyMlwiLFxuICAgICAgICAgICAgbiA9IGUuZGF0YXNldC5pbmxpbmVUd2VldFVybCA/IGUuZGF0YXNldC5pbmxpbmVUd2VldFVybCA6IHdpbmRvdy5sb2NhdGlvbi5ocmVmLFxuICAgICAgICAgICAgYSA9IGUuZGF0YXNldC5pbmxpbmVUd2VldFZpYSA/IFwiJnZpYT1cIiArIGUuZGF0YXNldC5pbmxpbmVUd2VldFZpYSA6IFwiXCIsXG4gICAgICAgICAgICByID0gZS5kYXRhc2V0LmlubGluZVR3ZWV0VGFncyA/IFwiJmhhc2h0YWdzPVwiICsgZS5kYXRhc2V0LmlubGluZVR3ZWV0VGFncyA6IFwiXCIsXG4gICAgICAgICAgICBsID0gXCJodHRwczovL3R3aXR0ZXIuY29tL2ludGVudC90d2VldC8/dGV4dD1cIiArIGkgKyBcIiZ1cmw9XCIgKyBuICsgYSArIHIsXG4gICAgICAgICAgICBkID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNwYW5cIik7XG4gICAgICAgIGQuaW5uZXJIVE1MID0gdDtcbiAgICAgICAgdmFyIHMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiYVwiKTtcbiAgICAgICAgcy50YXJnZXQgPSBcIl9ibGFua1wiLCBzLmhyZWYgPSBsLCBzLmFwcGVuZENoaWxkKGQpLCBzLmlubmVySFRNTCArPSB0d2l0dGVyTG9nbywgZS5pbm5lckhUTUwgPSBcIlwiLCBlLmFwcGVuZENoaWxkKHMpXG4gICAgfVxuICAgIHZhciBpbmxpbmVUd2VldHMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKFwiKltkYXRhLWlubGluZS10d2VldF1cIik7XG4gICAgaWYgKGlubGluZVR3ZWV0cylcbiAgICAgICAgZm9yICh2YXIgdHdpdHRlckxvZ28gPSAnPHN2ZyBzdHlsZT1cImhlaWdodDogMC43ZW07XCIgeG1sbnM6cmRmPVwiaHR0cDovL3d3dy53My5vcmcvMTk5OS8wMi8yMi1yZGYtc3ludGF4LW5zI1wiIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiB4bWw6c3BhY2U9XCJwcmVzZXJ2ZVwiIHZlcnNpb249XCIxLjFcIiB4bWxuczpjYz1cImh0dHA6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL25zI1wiIHZpZXdCb3g9XCIwIDAgMTgyLjY2NjY3IDE1MC42NjY2N1wiIHhtbG5zOmRjPVwiaHR0cDovL3B1cmwub3JnL2RjL2VsZW1lbnRzLzEuMS9cIj48bWV0YWRhdGEgaWQ9XCJtZXRhZGF0YThcIj48cmRmOlJERj48Y2M6V29yayByZGY6YWJvdXQ9XCJcIj48ZGM6Zm9ybWF0PmltYWdlL3N2Zyt4bWw8L2RjOmZvcm1hdD48ZGM6dHlwZSByZGY6cmVzb3VyY2U9XCJodHRwOi8vcHVybC5vcmcvZGMvZGNtaXR5cGUvU3RpbGxJbWFnZVwiLz48L2NjOldvcms+PC9yZGY6UkRGPjwvbWV0YWRhdGE+PGRlZnMgaWQ9XCJkZWZzNlwiPjxjbGlwUGF0aCBpZD1cImNsaXBQYXRoMjBcIiBjbGlwUGF0aFVuaXRzPVwidXNlclNwYWNlT25Vc2VcIj48cGF0aCBpZD1cInBhdGgxOFwiIGQ9XCJtMCAxMC4wMTJoMTM2Ni45djExMTAuOWgtMTM2Ni45elwiLz48L2NsaXBQYXRoPjwvZGVmcz48ZyBpZD1cImcxMFwiIHRyYW5zZm9ybT1cIm1hdHJpeCgxLjMzMzMgMCAwIC0xLjMzMzMgMCAxNTAuNjcpXCI+PGcgaWQ9XCJnMTJcIiB0cmFuc2Zvcm09XCJzY2FsZSguMSlcIj48ZyBpZD1cImcxNFwiPjxnIGlkPVwiZzE2XCIgY2xpcC1wYXRoPVwidXJsKCNjbGlwUGF0aDIwKVwiPjxwYXRoIGlkPVwicGF0aDIyXCIgZD1cIm0xMzY2LjkgOTg5LjM5Yy01MC4yNy0yMi4zMDktMTA0LjMzLTM3LjM4Ny0xNjEuMDUtNDQuMTggNTcuODkgMzQuNzIzIDEwMi4zNCA4OS42NzkgMTIzLjI4IDE1NS4xNS01NC4xOC0zMi4xNS0xMTQuMTgtNTUuNDctMTc4LjA5LTY4LjA0LTUxLjEzIDU0LjQ5LTEyNC4wMiA4OC41NS0yMDQuNjggODguNTUtMTU0Ljg5IDAtMjgwLjQzLTEyNS41NS0yODAuNDMtMjgwLjQzIDAtMjEuOTg4IDIuNDU3LTQzLjM5OCA3LjI1OC02My45MS0yMzMuMDggMTEuNjgtNDM5LjcyIDEyMy4zNi01NzguMDQgMjkzLjAxLTI0LjE0MS00MS40LTM3Ljk2OS04OS41NjctMzcuOTY5LTE0MC45NyAwLTk3LjMwOCA0OS40ODktMTgzLjEzIDEyNC43Ni0yMzMuNDQtNDUuOTY5IDEuNDM3LTg5LjIxOCAxNC4wNTgtMTI3LjAzIDM1LjA3OC0wLjA0My0xLjE4LTAuMDQzLTIuMzQ4LTAuMDQzLTMuNTIgMC0xMzUuOSA5Ni42OC0yNDkuMjIgMjI0Ljk2LTI3NS0yMy41MTItNi40MS00OC4yODEtOS44LTczLjg2LTkuOC0xOC4wODkgMC0zNS42MjggMS43MTEtNTIuNzgxIDUgMzUuNzExLTExMS40MSAxMzkuMjYtMTkyLjUgMjYyLTE5NC43Ny05Ni4wNTgtNzUuMjMtMjE2Ljk2LTEyMC4wNC0zNDguMzYtMTIwLjA0LTIyLjYyMSAwLTQ0Ljk2MSAxLjMzMi02Ni45MTggMy45MSAxMjQuMTYtNzkuNTY4IDI3MS41NS0xMjUuOTggNDI5Ljk0LTEyNS45OCA1MTUuODIgMCA3OTcuODYgNDI3LjMxIDc5Ny44NiA3OTcuOTMgMCAxMi4xNTMtMC4yOCAyNC4yMjMtMC43OSAzNi4yNSA1NC43NyAzOS41NzEgMTAyLjMxIDg4Ljk1IDEzOS45MyAxNDUuMlwiIGZpbGw9XCIjNTVBQ0VFXCIvPjwvZz48L2c+PC9nPjwvZz48L3N2Zz4nLCBpID0gMDsgaSA8IGlubGluZVR3ZWV0cy5sZW5ndGg7IGkrKykgYnVpbGRJbmxpbmVUd2VldChpbmxpbmVUd2VldHNbaV0pO1xufVxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9leHRyYXMuanNcbiAqKi8iXSwic291cmNlUm9vdCI6IiJ9